CCS PCM C Compiler, Version 4.104, 5967               18-out-23 23:18

               Filename: D:\Microcontroladores\Trabalho_Fechadura\main.lst

               ROM used: 1759 words (21%)
                         Largest free fragment is 2048
               RAM used: 22 (6%) at main() level
                         38 (10%) worst case
               Stack:    5 locations

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   5AC
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
05B7:  BCF    03.5
05B8:  CLRF   20
05B9:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... #ifndef STDBOOL_H 
.................... #define STDBOOL_h 
....................  
.................... #define bool _Bool 
.................... #ifndef true 
.................... #define true 1 
.................... #endif 
....................  
.................... #ifndef false 
.................... #define false 0 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // #device adc=8 
....................  
.................... #FUSES NOWDT     // No Watch Dog Timer 
.................... #FUSES XT        // High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT     // No Power Up Timer 
.................... #FUSES NOPROTECT // Code not protected from reading 
.................... #FUSES NODEBUG   // No Debug mode for ICD 
.................... #FUSES BROWNOUT  // Reset when brownout detected 
.................... #FUSES NOLVP     // No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD     // No EE protection 
.................... #FUSES NOWRT     // Program memory not write protected 
.................... #FUSES RESERVED  // Used to set the reserved FUSE bits 
....................  
.................... #use delay(clock = 4000000) 
*
0066:  MOVLW  39
0067:  MOVWF  04
0068:  BCF    03.7
0069:  MOVF   00,W
006A:  BTFSC  03.2
006B:  GOTO   07A
006C:  MOVLW  01
006D:  MOVWF  78
006E:  CLRF   77
006F:  DECFSZ 77,F
0070:  GOTO   06F
0071:  DECFSZ 78,F
0072:  GOTO   06E
0073:  MOVLW  4A
0074:  MOVWF  77
0075:  DECFSZ 77,F
0076:  GOTO   075
0077:  GOTO   078
0078:  DECFSZ 00,F
0079:  GOTO   06C
007A:  RETURN
....................  
.................... #ifndef lcd_enable 
.................... #define lcd_enable pin_A3 // pino enable do LCD 
.................... #define lcd_rs pin_A5     // pino rs do LCD 
.................... #define lcd_rw pin_A4     // pino rw do LCD 
.................... #define lcd_d4 pin_d4     // pino de dados d4 do LCD 
.................... #define lcd_d5 pin_d5     // pino de dados d5 do LCD 
.................... #define lcd_d6 pin_d6     // pino de dados d6 do LCD 
.................... #define lcd_d7 pin_d7     // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulação de módulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fábio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variável de leitura 
.................... 	// lê os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dá um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lê os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
007B:  BTFSC  40.0
007C:  GOTO   07F
007D:  BCF    08.4
007E:  GOTO   080
007F:  BSF    08.4
0080:  BSF    03.5
0081:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
0082:  BCF    03.5
0083:  BTFSC  40.1
0084:  GOTO   087
0085:  BCF    08.5
0086:  GOTO   088
0087:  BSF    08.5
0088:  BSF    03.5
0089:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
008A:  BCF    03.5
008B:  BTFSC  40.2
008C:  GOTO   08F
008D:  BCF    08.6
008E:  GOTO   090
008F:  BSF    08.6
0090:  BSF    03.5
0091:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
0092:  BCF    03.5
0093:  BTFSC  40.3
0094:  GOTO   097
0095:  BCF    08.7
0096:  GOTO   098
0097:  BSF    08.7
0098:  BSF    03.5
0099:  BCF    08.7
.................... 	// dá um pulso na linha enable 
.................... 	output_high(lcd_enable); 
009A:  BCF    05.3
009B:  BCF    03.5
009C:  BSF    05.3
.................... 	output_low(lcd_enable); 
009D:  BSF    03.5
009E:  BCF    05.3
009F:  BCF    03.5
00A0:  BCF    05.3
.................... } 
00A1:  RETURN
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
00A2:  BSF    03.5
00A3:  BCF    05.5
00A4:  BCF    03.5
00A5:  BCF    05.5
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
00A6:  MOVF   3D,F
00A7:  BTFSS  03.2
00A8:  GOTO   0AB
00A9:  BCF    05.5
00AA:  GOTO   0AC
00AB:  BSF    05.5
00AC:  BSF    03.5
00AD:  BCF    05.5
.................... 	delay_us(100);	// aguarda 100 us 
00AE:  MOVLW  21
00AF:  MOVWF  77
00B0:  DECFSZ 77,F
00B1:  GOTO   0B0
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
00B2:  BCF    05.4
00B3:  BCF    03.5
00B4:  BCF    05.4
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
00B5:  BSF    03.5
00B6:  BCF    05.3
00B7:  BCF    03.5
00B8:  BCF    05.3
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
00B9:  SWAPF  3E,W
00BA:  MOVWF  3F
00BB:  MOVLW  0F
00BC:  ANDWF  3F,F
00BD:  MOVF   3F,W
00BE:  MOVWF  40
00BF:  CALL   07B
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
00C0:  MOVF   3E,W
00C1:  ANDLW  0F
00C2:  MOVWF  3F
00C3:  MOVWF  40
00C4:  CALL   07B
.................... } 
00C5:  RETURN
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
00C6:  BSF    03.5
00C7:  BCF    08.4
00C8:  BCF    03.5
00C9:  BCF    08.4
.................... 	output_low(lcd_d5); 
00CA:  BSF    03.5
00CB:  BCF    08.5
00CC:  BCF    03.5
00CD:  BCF    08.5
.................... 	output_low(lcd_d6); 
00CE:  BSF    03.5
00CF:  BCF    08.6
00D0:  BCF    03.5
00D1:  BCF    08.6
.................... 	output_low(lcd_d7); 
00D2:  BSF    03.5
00D3:  BCF    08.7
00D4:  BCF    03.5
00D5:  BCF    08.7
.................... 	output_low(lcd_rs); 
00D6:  BSF    03.5
00D7:  BCF    05.5
00D8:  BCF    03.5
00D9:  BCF    05.5
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
00DA:  BSF    03.5
00DB:  BCF    05.4
00DC:  BCF    03.5
00DD:  BSF    05.4
.................... 	#endif 
.................... 	output_low(lcd_enable); 
00DE:  BSF    03.5
00DF:  BCF    05.3
00E0:  BCF    03.5
00E1:  BCF    05.3
.................... 	delay_ms(15); 
00E2:  MOVLW  0F
00E3:  MOVWF  39
00E4:  CALL   066
.................... 	// envia uma seqüência de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o módulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
00E5:  MOVLW  01
00E6:  MOVWF  2F
00E7:  MOVF   2F,W
00E8:  SUBLW  03
00E9:  BTFSS  03.0
00EA:  GOTO   0F3
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
00EB:  MOVLW  03
00EC:  MOVWF  40
00ED:  CALL   07B
.................... 		delay_ms(5); 
00EE:  MOVLW  05
00EF:  MOVWF  39
00F0:  CALL   066
.................... 	} 
00F1:  INCF   2F,F
00F2:  GOTO   0E7
.................... 	lcd_envia_nibble(2); 
00F3:  MOVLW  02
00F4:  MOVWF  40
00F5:  CALL   07B
.................... 	// envia string de inicialização do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
00F6:  CLRF   2F
00F7:  MOVF   2F,W
00F8:  SUBLW  03
00F9:  BTFSS  03.0
00FA:  GOTO   104
00FB:  MOVF   2F,W
00FC:  CALL   004
00FD:  MOVWF  30
00FE:  CLRF   3D
00FF:  MOVF   30,W
0100:  MOVWF  3E
0101:  CALL   0A2
0102:  INCF   2F,F
0103:  GOTO   0F7
.................... } 
0104:  BCF    0A.3
0105:  BCF    0A.4
0106:  GOTO   604 (RETURN)
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0205:  DECFSZ 3A,W
0206:  GOTO   208
0207:  GOTO   20B
....................    	endereco = lcd_seg_lin; 
0208:  MOVLW  40
0209:  MOVWF  3B
....................    else 
020A:  GOTO   20C
....................    	endereco = 0; 
020B:  CLRF   3B
....................    endereco += x-1; 
020C:  MOVLW  01
020D:  SUBWF  39,W
020E:  ADDWF  3B,F
....................    lcd_envia_byte(0,0x80|endereco); 
020F:  MOVF   3B,W
0210:  IORLW  80
0211:  MOVWF  3C
0212:  CLRF   3D
0213:  MOVF   3C,W
0214:  MOVWF  3E
0215:  CALL   0A2
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
.................... 	{ 
*
01EB:  MOVF   38,W
01EC:  XORLW  0C
01ED:  BTFSC  03.2
01EE:  GOTO   1F9
01EF:  XORLW  06
01F0:  BTFSC  03.2
01F1:  GOTO   201
01F2:  XORLW  07
01F3:  BTFSC  03.2
01F4:  GOTO   201
01F5:  XORLW  05
01F6:  BTFSC  03.2
01F7:  GOTO   217
01F8:  GOTO   21C
....................      case '\f' 	:	lcd_envia_byte(0,1); 
01F9:  CLRF   3D
01FA:  MOVLW  01
01FB:  MOVWF  3E
01FC:  CALL   0A2
.................... 	  			delay_ms(2); 
01FD:  MOVLW  02
01FE:  MOVWF  39
01FF:  CALL   066
.................... 				break; 
0200:  GOTO   222
....................      case '\n'	: 
.................... 	 case '\r' 	:	lcd_pos_xy(1,2); 
0201:  MOVLW  01
0202:  MOVWF  39
0203:  MOVLW  02
0204:  MOVWF  3A
.................... 	  			break; 
*
0216:  GOTO   222
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
0217:  CLRF   3D
0218:  MOVLW  10
0219:  MOVWF  3E
021A:  CALL   0A2
.................... 	  			break; 
021B:  GOTO   222
....................      default	:	lcd_envia_byte(1,c); 
021C:  MOVLW  01
021D:  MOVWF  3D
021E:  MOVF   38,W
021F:  MOVWF  3E
0220:  CALL   0A2
.................... 	  			break; 
0221:  GOTO   222
....................    } 
.................... } 
0222:  RETURN
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posição do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lê o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
.................... #include "kbd_ext_board2.c" 
.................... /*######################################################################  
....................  Rotina utilizaÃ§Ã£oo do teclado da placa PicSim board4 
....................  Adaptada para o compilador CCS 
....................  Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................  For e-mail suggestions : awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
.................... { 
*
0281:  CLRF   30
0282:  CLRF   31
....................  unsigned int to=0; 
....................  unsigned char k = 0;  
....................  while(((to < timeout)||(!timeout))&&(!k)){ 
0283:  MOVF   2F,W
0284:  SUBWF  30,W
0285:  BTFSS  03.0
0286:  GOTO   28A
0287:  MOVF   2F,F
0288:  BTFSS  03.2
0289:  GOTO   39F
028A:  MOVF   31,F
028B:  BTFSS  03.2
028C:  GOTO   39F
....................   
....................   
....................  //------------------------------------------------------------------------- 
....................  //inicio do programa de varredura do teclado matricial 
....................  //-------------------------------------------------------------------------- 
....................  //habilita primeira coluna do teclado 
....................  output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
028D:  BSF    03.5
028E:  BCF    06.0
028F:  BCF    03.5
0290:  BCF    06.0
0291:  BSF    03.5
0292:  BCF    06.1
0293:  BCF    03.5
0294:  BSF    06.1
0295:  BSF    03.5
0296:  BCF    06.2
0297:  BCF    03.5
0298:  BSF    06.2
0299:  BSF    03.5
029A:  BCF    06.3
029B:  BCF    03.5
029C:  BSF    06.3
....................  delay_ms(20); 
029D:  MOVLW  14
029E:  MOVWF  39
029F:  CALL   066
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
02A0:  BSF    03.5
02A1:  BSF    08.0
02A2:  BCF    03.5
02A3:  BTFSC  08.0
02A4:  GOTO   2AC
02A5:  BSF    03.5
02A6:  BSF    08.0
02A7:  BCF    03.5
02A8:  BTFSS  08.0
02A9:  GOTO   2A5
02AA:  MOVLW  31
02AB:  MOVWF  31
....................  if (input(PIN_D1) == 0){ 
02AC:  BSF    03.5
02AD:  BSF    08.1
02AE:  BCF    03.5
02AF:  BTFSC  08.1
02B0:  GOTO   2B8
....................  while(input(PIN_D1) == 0); 
02B1:  BSF    03.5
02B2:  BSF    08.1
02B3:  BCF    03.5
02B4:  BTFSS  08.1
02B5:  GOTO   2B1
....................  k='4'; 
02B6:  MOVLW  34
02B7:  MOVWF  31
....................  }; 
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
02B8:  BSF    03.5
02B9:  BSF    08.2
02BA:  BCF    03.5
02BB:  BTFSC  08.2
02BC:  GOTO   2C4
02BD:  BSF    03.5
02BE:  BSF    08.2
02BF:  BCF    03.5
02C0:  BTFSS  08.2
02C1:  GOTO   2BD
02C2:  MOVLW  37
02C3:  MOVWF  31
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
02C4:  BSF    03.5
02C5:  BSF    08.3
02C6:  BCF    03.5
02C7:  BTFSC  08.3
02C8:  GOTO   2D0
02C9:  BSF    03.5
02CA:  BSF    08.3
02CB:  BCF    03.5
02CC:  BTFSS  08.3
02CD:  GOTO   2C9
02CE:  MOVLW  2A
02CF:  MOVWF  31
....................  //habilita segunda coluna do teclado 
....................  output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
02D0:  BSF    03.5
02D1:  BCF    06.0
02D2:  BCF    03.5
02D3:  BSF    06.0
02D4:  BSF    03.5
02D5:  BCF    06.1
02D6:  BCF    03.5
02D7:  BCF    06.1
02D8:  BSF    03.5
02D9:  BCF    06.2
02DA:  BCF    03.5
02DB:  BSF    06.2
02DC:  BSF    03.5
02DD:  BCF    06.3
02DE:  BCF    03.5
02DF:  BSF    06.3
....................  delay_ms(20);  
02E0:  MOVLW  14
02E1:  MOVWF  39
02E2:  CALL   066
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
02E3:  BSF    03.5
02E4:  BSF    08.0
02E5:  BCF    03.5
02E6:  BTFSC  08.0
02E7:  GOTO   2EF
02E8:  BSF    03.5
02E9:  BSF    08.0
02EA:  BCF    03.5
02EB:  BTFSS  08.0
02EC:  GOTO   2E8
02ED:  MOVLW  32
02EE:  MOVWF  31
....................  if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
02EF:  BSF    03.5
02F0:  BSF    08.1
02F1:  BCF    03.5
02F2:  BTFSC  08.1
02F3:  GOTO   2FB
02F4:  BSF    03.5
02F5:  BSF    08.1
02F6:  BCF    03.5
02F7:  BTFSS  08.1
02F8:  GOTO   2F4
02F9:  MOVLW  35
02FA:  MOVWF  31
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
02FB:  BSF    03.5
02FC:  BSF    08.2
02FD:  BCF    03.5
02FE:  BTFSC  08.2
02FF:  GOTO   307
0300:  BSF    03.5
0301:  BSF    08.2
0302:  BCF    03.5
0303:  BTFSS  08.2
0304:  GOTO   300
0305:  MOVLW  38
0306:  MOVWF  31
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
0307:  BSF    03.5
0308:  BSF    08.3
0309:  BCF    03.5
030A:  BTFSC  08.3
030B:  GOTO   313
030C:  BSF    03.5
030D:  BSF    08.3
030E:  BCF    03.5
030F:  BTFSS  08.3
0310:  GOTO   30C
0311:  MOVLW  30
0312:  MOVWF  31
....................   
....................  //habilita terceira coluna do teclado 
....................  output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
0313:  BSF    03.5
0314:  BCF    06.0
0315:  BCF    03.5
0316:  BSF    06.0
0317:  BSF    03.5
0318:  BCF    06.1
0319:  BCF    03.5
031A:  BSF    06.1
031B:  BSF    03.5
031C:  BCF    06.2
031D:  BCF    03.5
031E:  BCF    06.2
031F:  BSF    03.5
0320:  BCF    06.3
0321:  BCF    03.5
0322:  BSF    06.3
....................  delay_ms(20);  
0323:  MOVLW  14
0324:  MOVWF  39
0325:  CALL   066
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
0326:  BSF    03.5
0327:  BSF    08.0
0328:  BCF    03.5
0329:  BTFSC  08.0
032A:  GOTO   332
032B:  BSF    03.5
032C:  BSF    08.0
032D:  BCF    03.5
032E:  BTFSS  08.0
032F:  GOTO   32B
0330:  MOVLW  33
0331:  MOVWF  31
....................  if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
0332:  BSF    03.5
0333:  BSF    08.1
0334:  BCF    03.5
0335:  BTFSC  08.1
0336:  GOTO   33E
0337:  BSF    03.5
0338:  BSF    08.1
0339:  BCF    03.5
033A:  BTFSS  08.1
033B:  GOTO   337
033C:  MOVLW  36
033D:  MOVWF  31
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
033E:  BSF    03.5
033F:  BSF    08.2
0340:  BCF    03.5
0341:  BTFSC  08.2
0342:  GOTO   34A
0343:  BSF    03.5
0344:  BSF    08.2
0345:  BCF    03.5
0346:  BTFSS  08.2
0347:  GOTO   343
0348:  MOVLW  39
0349:  MOVWF  31
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
034A:  BSF    03.5
034B:  BSF    08.3
034C:  BCF    03.5
034D:  BTFSC  08.3
034E:  GOTO   356
034F:  BSF    03.5
0350:  BSF    08.3
0351:  BCF    03.5
0352:  BTFSS  08.3
0353:  GOTO   34F
0354:  MOVLW  23
0355:  MOVWF  31
....................  //habilita quarta coluna do teclado 
....................  output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
0356:  BSF    03.5
0357:  BCF    06.0
0358:  BCF    03.5
0359:  BSF    06.0
035A:  BSF    03.5
035B:  BCF    06.1
035C:  BCF    03.5
035D:  BSF    06.1
035E:  BSF    03.5
035F:  BCF    06.2
0360:  BCF    03.5
0361:  BSF    06.2
0362:  BSF    03.5
0363:  BCF    06.3
0364:  BCF    03.5
0365:  BCF    06.3
....................  delay_ms(20);  
0366:  MOVLW  14
0367:  MOVWF  39
0368:  CALL   066
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
0369:  BSF    03.5
036A:  BSF    08.0
036B:  BCF    03.5
036C:  BTFSC  08.0
036D:  GOTO   375
036E:  BSF    03.5
036F:  BSF    08.0
0370:  BCF    03.5
0371:  BTFSS  08.0
0372:  GOTO   36E
0373:  MOVLW  41
0374:  MOVWF  31
....................  if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
0375:  BSF    03.5
0376:  BSF    08.1
0377:  BCF    03.5
0378:  BTFSC  08.1
0379:  GOTO   381
037A:  BSF    03.5
037B:  BSF    08.1
037C:  BCF    03.5
037D:  BTFSS  08.1
037E:  GOTO   37A
037F:  MOVLW  42
0380:  MOVWF  31
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
0381:  BSF    03.5
0382:  BSF    08.2
0383:  BCF    03.5
0384:  BTFSC  08.2
0385:  GOTO   38D
0386:  BSF    03.5
0387:  BSF    08.2
0388:  BCF    03.5
0389:  BTFSS  08.2
038A:  GOTO   386
038B:  MOVLW  43
038C:  MOVWF  31
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
038D:  BSF    03.5
038E:  BSF    08.3
038F:  BCF    03.5
0390:  BTFSC  08.3
0391:  GOTO   399
0392:  BSF    03.5
0393:  BSF    08.3
0394:  BCF    03.5
0395:  BTFSS  08.3
0396:  GOTO   392
0397:  MOVLW  44
0398:  MOVWF  31
....................   
....................  delay_ms(5); 
0399:  MOVLW  05
039A:  MOVWF  39
039B:  CALL   066
....................  to+=5; 
039C:  MOVLW  05
039D:  ADDWF  30,F
....................  } 
039E:  GOTO   283
....................  if(!k)k=255; 
039F:  MOVF   31,F
03A0:  BTFSS  03.2
03A1:  GOTO   3A4
03A2:  MOVLW  FF
03A3:  MOVWF  31
....................  return k;  
03A4:  MOVF   31,W
03A5:  MOVWF  78
.................... } 
03A6:  BCF    0A.3
03A7:  BCF    0A.4
03A8:  GOTO   63A (RETURN)
....................  
.................... #include "2408.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC08B                                 //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0114:  MOVLW  08
0115:  MOVWF  78
0116:  NOP
0117:  BCF    07.3
0118:  BCF    22.3
0119:  MOVF   22,W
011A:  BSF    03.5
011B:  MOVWF  07
011C:  NOP
011D:  BCF    03.5
011E:  RLF    36,F
011F:  BCF    07.4
0120:  BTFSS  03.0
0121:  GOTO   128
0122:  BSF    22.4
0123:  MOVF   22,W
0124:  BSF    03.5
0125:  MOVWF  07
0126:  GOTO   12C
0127:  BCF    03.5
0128:  BCF    22.4
0129:  MOVF   22,W
012A:  BSF    03.5
012B:  MOVWF  07
012C:  NOP
012D:  BCF    03.5
012E:  BSF    22.3
012F:  MOVF   22,W
0130:  BSF    03.5
0131:  MOVWF  07
0132:  BCF    03.5
0133:  BTFSS  07.3
0134:  GOTO   133
0135:  DECFSZ 78,F
0136:  GOTO   116
0137:  NOP
0138:  BCF    07.3
0139:  BCF    22.3
013A:  MOVF   22,W
013B:  BSF    03.5
013C:  MOVWF  07
013D:  NOP
013E:  BCF    03.5
013F:  BSF    22.4
0140:  MOVF   22,W
0141:  BSF    03.5
0142:  MOVWF  07
0143:  NOP
0144:  NOP
0145:  BCF    03.5
0146:  BSF    22.3
0147:  MOVF   22,W
0148:  BSF    03.5
0149:  MOVWF  07
014A:  BCF    03.5
014B:  BTFSS  07.3
014C:  GOTO   14B
014D:  CLRF   78
014E:  NOP
014F:  BTFSC  07.4
0150:  BSF    78.0
0151:  BCF    07.3
0152:  BCF    22.3
0153:  MOVF   22,W
0154:  BSF    03.5
0155:  MOVWF  07
0156:  BCF    03.5
0157:  BCF    07.4
0158:  BCF    22.4
0159:  MOVF   22,W
015A:  BSF    03.5
015B:  MOVWF  07
015C:  BCF    03.5
015D:  RETURN
*
054D:  MOVLW  08
054E:  MOVWF  36
054F:  MOVF   77,W
0550:  MOVWF  37
0551:  BSF    22.4
0552:  MOVF   22,W
0553:  BSF    03.5
0554:  MOVWF  07
0555:  NOP
0556:  BCF    03.5
0557:  BSF    22.3
0558:  MOVF   22,W
0559:  BSF    03.5
055A:  MOVWF  07
055B:  BCF    03.5
055C:  BTFSS  07.3
055D:  GOTO   55C
055E:  BTFSC  07.4
055F:  BSF    03.0
0560:  BTFSS  07.4
0561:  BCF    03.0
0562:  RLF    78,F
0563:  NOP
0564:  BCF    22.3
0565:  MOVF   22,W
0566:  BSF    03.5
0567:  MOVWF  07
0568:  BCF    03.5
0569:  BCF    07.3
056A:  DECFSZ 36,F
056B:  GOTO   551
056C:  BSF    22.4
056D:  MOVF   22,W
056E:  BSF    03.5
056F:  MOVWF  07
0570:  NOP
0571:  BCF    03.5
0572:  BCF    07.4
0573:  MOVF   37,W
0574:  BTFSC  03.2
0575:  GOTO   57B
0576:  BCF    22.4
0577:  MOVF   22,W
0578:  BSF    03.5
0579:  MOVWF  07
057A:  BCF    03.5
057B:  NOP
057C:  BSF    22.3
057D:  MOVF   22,W
057E:  BSF    03.5
057F:  MOVWF  07
0580:  BCF    03.5
0581:  BTFSS  07.3
0582:  GOTO   581
0583:  NOP
0584:  BCF    07.3
0585:  BCF    22.3
0586:  MOVF   22,W
0587:  BSF    03.5
0588:  MOVWF  07
0589:  NOP
058A:  BCF    03.5
058B:  BCF    07.4
058C:  BCF    22.4
058D:  MOVF   22,W
058E:  BSF    03.5
058F:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE    1024 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0107:  BSF    22.3
0108:  MOVF   22,W
0109:  BSF    03.5
010A:  MOVWF  07
....................    output_float(EEPROM_SDA); 
010B:  BCF    03.5
010C:  BSF    22.4
010D:  MOVF   22,W
010E:  BSF    03.5
010F:  MOVWF  07
.................... } 
0110:  BCF    03.5
0111:  BCF    0A.3
0112:  BCF    0A.4
0113:  GOTO   608 (RETURN)
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
015E:  BSF    22.4
015F:  MOVF   22,W
0160:  BSF    03.5
0161:  MOVWF  07
0162:  NOP
0163:  BCF    03.5
0164:  BSF    22.3
0165:  MOVF   22,W
0166:  BSF    03.5
0167:  MOVWF  07
0168:  NOP
0169:  BCF    03.5
016A:  BCF    07.4
016B:  BCF    22.4
016C:  MOVF   22,W
016D:  BSF    03.5
016E:  MOVWF  07
016F:  NOP
0170:  BCF    03.5
0171:  BCF    07.3
0172:  BCF    22.3
0173:  MOVF   22,W
0174:  BSF    03.5
0175:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
0176:  MOVLW  A0
0177:  BCF    03.5
0178:  MOVWF  36
0179:  CALL   114
017A:  MOVF   78,W
017B:  BCF    35.0
017C:  BTFSC  78.0
017D:  BSF    35.0
....................    i2c_stop(); 
017E:  BCF    22.4
017F:  MOVF   22,W
0180:  BSF    03.5
0181:  MOVWF  07
0182:  NOP
0183:  BCF    03.5
0184:  BSF    22.3
0185:  MOVF   22,W
0186:  BSF    03.5
0187:  MOVWF  07
0188:  BCF    03.5
0189:  BTFSS  07.3
018A:  GOTO   189
018B:  NOP
018C:  GOTO   18D
018D:  NOP
018E:  BSF    22.4
018F:  MOVF   22,W
0190:  BSF    03.5
0191:  MOVWF  07
0192:  NOP
....................    return !ack; 
0193:  MOVLW  00
0194:  BCF    03.5
0195:  BTFSS  35.0
0196:  MOVLW  01
0197:  MOVWF  78
.................... } 
0198:  RETURN
....................  
.................... void write_ext_eeprom(long int address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
0199:  CALL   15E
019A:  MOVF   78,F
019B:  BTFSC  03.2
019C:  GOTO   199
....................    i2c_start(); 
019D:  BSF    22.4
019E:  MOVF   22,W
019F:  BSF    03.5
01A0:  MOVWF  07
01A1:  NOP
01A2:  BCF    03.5
01A3:  BSF    22.3
01A4:  MOVF   22,W
01A5:  BSF    03.5
01A6:  MOVWF  07
01A7:  NOP
01A8:  BCF    03.5
01A9:  BCF    07.4
01AA:  BCF    22.4
01AB:  MOVF   22,W
01AC:  BSF    03.5
01AD:  MOVWF  07
01AE:  NOP
01AF:  BCF    03.5
01B0:  BCF    07.3
01B1:  BCF    22.3
01B2:  MOVF   22,W
01B3:  BSF    03.5
01B4:  MOVWF  07
....................    i2c_write((0xa0|(BYTE)(address>>7))&0xfe); 
01B5:  BCF    03.5
01B6:  RRF    30,W
01B7:  MOVWF  7A
01B8:  RRF    2F,W
01B9:  MOVWF  79
01BA:  RRF    7A,F
01BB:  RRF    79,F
01BC:  RRF    7A,F
01BD:  RRF    79,F
01BE:  RRF    7A,F
01BF:  RRF    79,F
01C0:  RRF    7A,F
01C1:  RRF    79,F
01C2:  RRF    7A,F
01C3:  RRF    79,F
01C4:  RRF    7A,F
01C5:  RRF    79,F
01C6:  MOVLW  01
01C7:  ANDWF  7A,F
01C8:  MOVF   79,W
01C9:  IORLW  A0
01CA:  ANDLW  FE
01CB:  MOVWF  32
01CC:  MOVWF  36
01CD:  CALL   114
....................    i2c_write(address); 
01CE:  MOVF   2F,W
01CF:  MOVWF  36
01D0:  CALL   114
....................    i2c_write(data); 
01D1:  MOVF   31,W
01D2:  MOVWF  36
01D3:  CALL   114
....................    i2c_stop(); 
01D4:  BCF    22.4
01D5:  MOVF   22,W
01D6:  BSF    03.5
01D7:  MOVWF  07
01D8:  NOP
01D9:  BCF    03.5
01DA:  BSF    22.3
01DB:  MOVF   22,W
01DC:  BSF    03.5
01DD:  MOVWF  07
01DE:  BCF    03.5
01DF:  BTFSS  07.3
01E0:  GOTO   1DF
01E1:  NOP
01E2:  GOTO   1E3
01E3:  NOP
01E4:  BSF    22.4
01E5:  MOVF   22,W
01E6:  BSF    03.5
01E7:  MOVWF  07
01E8:  NOP
.................... } 
01E9:  BCF    03.5
01EA:  RETURN
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
04E1:  CALL   15E
04E2:  MOVF   78,F
04E3:  BTFSC  03.2
04E4:  GOTO   4E1
....................    i2c_start(); 
04E5:  BSF    22.4
04E6:  MOVF   22,W
04E7:  BSF    03.5
04E8:  MOVWF  07
04E9:  NOP
04EA:  BCF    03.5
04EB:  BSF    22.3
04EC:  MOVF   22,W
04ED:  BSF    03.5
04EE:  MOVWF  07
04EF:  NOP
04F0:  BCF    03.5
04F1:  BCF    07.4
04F2:  BCF    22.4
04F3:  MOVF   22,W
04F4:  BSF    03.5
04F5:  MOVWF  07
04F6:  NOP
04F7:  BCF    03.5
04F8:  BCF    07.3
04F9:  BCF    22.3
04FA:  MOVF   22,W
04FB:  BSF    03.5
04FC:  MOVWF  07
....................    i2c_write((0xa0|(BYTE)(address>>7))&0xfe); 
04FD:  BCF    03.5
04FE:  RRF    33,W
04FF:  MOVWF  7A
0500:  RRF    32,W
0501:  MOVWF  79
0502:  RRF    7A,F
0503:  RRF    79,F
0504:  RRF    7A,F
0505:  RRF    79,F
0506:  RRF    7A,F
0507:  RRF    79,F
0508:  RRF    7A,F
0509:  RRF    79,F
050A:  RRF    7A,F
050B:  RRF    79,F
050C:  RRF    7A,F
050D:  RRF    79,F
050E:  MOVLW  01
050F:  ANDWF  7A,F
0510:  MOVF   79,W
0511:  IORLW  A0
0512:  ANDLW  FE
0513:  MOVWF  35
0514:  MOVWF  36
0515:  CALL   114
....................    i2c_write(address); 
0516:  MOVF   32,W
0517:  MOVWF  36
0518:  CALL   114
....................    i2c_start(); 
0519:  BSF    22.4
051A:  MOVF   22,W
051B:  BSF    03.5
051C:  MOVWF  07
051D:  NOP
051E:  BCF    03.5
051F:  BSF    22.3
0520:  MOVF   22,W
0521:  BSF    03.5
0522:  MOVWF  07
0523:  NOP
0524:  BCF    03.5
0525:  BTFSS  07.3
0526:  GOTO   525
0527:  BCF    07.4
0528:  BCF    22.4
0529:  MOVF   22,W
052A:  BSF    03.5
052B:  MOVWF  07
052C:  NOP
052D:  BCF    03.5
052E:  BCF    07.3
052F:  BCF    22.3
0530:  MOVF   22,W
0531:  BSF    03.5
0532:  MOVWF  07
....................    i2c_write((0xa0|(BYTE)(address>>7))|1); 
0533:  BCF    03.5
0534:  RRF    33,W
0535:  MOVWF  7A
0536:  RRF    32,W
0537:  MOVWF  79
0538:  RRF    7A,F
0539:  RRF    79,F
053A:  RRF    7A,F
053B:  RRF    79,F
053C:  RRF    7A,F
053D:  RRF    79,F
053E:  RRF    7A,F
053F:  RRF    79,F
0540:  RRF    7A,F
0541:  RRF    79,F
0542:  RRF    7A,F
0543:  RRF    79,F
0544:  MOVLW  01
0545:  ANDWF  7A,F
0546:  MOVF   79,W
0547:  IORLW  A0
0548:  IORLW  01
0549:  MOVWF  35
054A:  MOVWF  36
054B:  CALL   114
....................    data=i2c_read(0); 
054C:  CLRF   77
*
0590:  MOVF   78,W
0591:  BCF    03.5
0592:  MOVWF  34
....................    i2c_stop(); 
0593:  BCF    22.4
0594:  MOVF   22,W
0595:  BSF    03.5
0596:  MOVWF  07
0597:  NOP
0598:  BCF    03.5
0599:  BSF    22.3
059A:  MOVF   22,W
059B:  BSF    03.5
059C:  MOVWF  07
059D:  BCF    03.5
059E:  BTFSS  07.3
059F:  GOTO   59E
05A0:  NOP
05A1:  GOTO   5A2
05A2:  NOP
05A3:  BSF    22.4
05A4:  MOVF   22,W
05A5:  BSF    03.5
05A6:  MOVWF  07
05A7:  NOP
....................    return(data); 
05A8:  BCF    03.5
05A9:  MOVF   34,W
05AA:  MOVWF  78
.................... } 
05AB:  RETURN
....................  
....................  
.................... long int End_HL(byte H, byte L) 
.................... { 
....................    return (H << 8) + L; 
.................... } 
....................  
.................... char *IntToHex(int value) 
.................... { 
....................    int a; 
....................    int b; 
....................    char *buffer; 
....................  
....................    a = value && 16; 
....................    b = (value >> 4) & 16; 
....................    buffer[0] = (a < 10) ? '0' + a : 'A' - (a - 10); 
....................    buffer[1] = (b < 10) ? '0' + b : 'A' - (b - 10); 
....................  
....................    return buffer; 
.................... } 
....................  
.................... void WRITE_FLOAT_EXT_EEPROM(long int n, float data) 
.................... { 
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
....................       write_ext_eeprom(i + n, *((int8 *)&data + i)); 
.................... } 
....................  
.................... float READ_FLOAT_EXT_EEPROM(long int n) 
.................... { 
....................    int i; 
....................    float data; 
....................  
....................    for (i = 0; i < 4; i++) 
....................       *((int8 *)&data + i) = read_ext_eeprom(i + n); 
....................  
....................    return ((float)data); 
.................... } 
....................  
.................... void eeprom_int16(unsigned int endereco, int16 valor_i16) 
.................... { 
....................    write_ext_eeprom(endereco, make8(valor_i16, 0)); 
....................    write_ext_eeprom(endereco + 1, make8(valor_i16, 1)); 
.................... } 
....................  
.................... int1 eTeclaValida(char c) 
.................... { 
....................    if (((int)c >= 48 && (int)c <= 57) || ((int)c >= 65 && (int)c <= 68) || ((int)c == 42 || (int)c == 35)) 
*
03A9:  MOVF   2F,W
03AA:  SUBLW  2F
03AB:  BTFSC  03.0
03AC:  GOTO   3B1
03AD:  MOVF   2F,W
03AE:  SUBLW  39
03AF:  BTFSC  03.0
03B0:  GOTO   3C1
03B1:  MOVF   2F,W
03B2:  SUBLW  40
03B3:  BTFSC  03.0
03B4:  GOTO   3B9
03B5:  MOVF   2F,W
03B6:  SUBLW  44
03B7:  BTFSC  03.0
03B8:  GOTO   3C1
03B9:  MOVF   2F,W
03BA:  SUBLW  2A
03BB:  BTFSC  03.2
03BC:  GOTO   3C1
03BD:  MOVF   2F,W
03BE:  SUBLW  23
03BF:  BTFSS  03.2
03C0:  GOTO   3C5
....................       return 1; 
03C1:  MOVLW  01
03C2:  MOVWF  78
03C3:  GOTO   3C8
....................    else 
03C4:  GOTO   3C8
....................       return 0; 
03C5:  MOVLW  00
03C6:  MOVWF  78
03C7:  GOTO   3C8
.................... } 
03C8:  BCF    0A.3
03C9:  BCF    0A.4
03CA:  GOTO   63F (RETURN)
....................  
.................... void desenhaTelaInicial() 
.................... { 
....................    printf(lcd_escreve, "\fSeja bem vindo!"); 
*
0269:  MOVLW  0C
026A:  BSF    03.6
026B:  MOVWF  0D
026C:  MOVLW  00
026D:  MOVWF  0F
026E:  BCF    03.6
026F:  CALL   223
....................    delay_ms(1000); 
0270:  MOVLW  04
0271:  MOVWF  2F
0272:  MOVLW  FA
0273:  MOVWF  39
0274:  CALL   066
0275:  DECFSZ 2F,F
0276:  GOTO   272
....................    printf(lcd_escreve, "\f1 - Cadastrar\n2 - Utilizar"); 
0277:  MOVLW  15
0278:  BSF    03.6
0279:  MOVWF  0D
027A:  MOVLW  00
027B:  MOVWF  0F
027C:  BCF    03.6
027D:  CALL   223
.................... } 
027E:  BCF    0A.3
027F:  BCF    0A.4
0280:  GOTO   630 (RETURN)
....................  
.................... void desenhaTelaUtilizar(char senha[]) 
.................... { 
....................    printf(lcd_escreve, "\fStatus: FECHADA\nSenha: %s", senha); 
*
04CB:  MOVLW  23
04CC:  BSF    03.6
04CD:  MOVWF  0D
04CE:  MOVLW  00
04CF:  MOVWF  0F
04D0:  BCF    03.0
04D1:  MOVLW  18
04D2:  BCF    03.6
04D3:  MOVWF  32
04D4:  CALL   3CB
04D5:  MOVF   2F,W
04D6:  MOVWF  04
04D7:  BCF    03.7
04D8:  BTFSC  30.0
04D9:  BSF    03.7
04DA:  CALL   493
....................    delay_ms(200); 
04DB:  MOVLW  C8
04DC:  MOVWF  39
04DD:  CALL   066
.................... } 
04DE:  BCF    0A.3
04DF:  BCF    0A.4
04E0:  GOTO   655 (RETURN)
....................  
.................... void desenhaTelaCadastrar(int userID, char senha[]) 
.................... { 
....................    printf(lcd_escreve, "\fID User: %d\nSenha: %s", userID, senha); 
*
04A9:  MOVLW  31
04AA:  BSF    03.6
04AB:  MOVWF  0D
04AC:  MOVLW  00
04AD:  MOVWF  0F
04AE:  BCF    03.0
04AF:  MOVLW  0A
04B0:  BCF    03.6
04B1:  MOVWF  32
04B2:  CALL   3CB
04B3:  MOVF   2F,W
04B4:  MOVWF  32
04B5:  MOVLW  1F
04B6:  MOVWF  33
04B7:  CALL   42E
04B8:  MOVLW  37
04B9:  BSF    03.6
04BA:  MOVWF  0D
04BB:  MOVLW  00
04BC:  MOVWF  0F
04BD:  BCF    03.0
04BE:  MOVLW  08
04BF:  BCF    03.6
04C0:  MOVWF  32
04C1:  CALL   3CB
04C2:  MOVF   30,W
04C3:  MOVWF  04
04C4:  BCF    03.7
04C5:  BTFSC  31.0
04C6:  BSF    03.7
04C7:  CALL   493
.................... } 
04C8:  BCF    0A.3
04C9:  BCF    0A.4
04CA:  GOTO   65D (RETURN)
....................  
.................... void main() 
.................... { 
*
05AC:  CLRF   04
05AD:  BCF    03.7
05AE:  MOVLW  1F
05AF:  ANDWF  03,F
05B0:  BSF    03.5
05B1:  BSF    1F.0
05B2:  BSF    1F.1
05B3:  BSF    1F.2
05B4:  BCF    1F.3
05B5:  MOVLW  07
05B6:  MOVWF  1C
*
05BD:  CLRF   27
05BE:  BSF    28.0
....................    char senha[4] = ""; 
*
05BC:  CLRF   23
....................    int8 cont = 0; 
....................    int1 senhaEstaCorreta = 1; 
....................    char senha_admin[4] = "0000"; 
*
05BF:  MOVLW  30
05C0:  MOVWF  29
05C1:  MOVWF  2A
05C2:  MOVWF  2B
05C3:  MOVWF  2C
....................    char tmp; 
....................  
....................    setup_adc_ports(AN0); 
05C4:  BSF    03.5
05C5:  BCF    1F.0
05C6:  BSF    1F.1
05C7:  BSF    1F.2
05C8:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_DIV_2); 
05C9:  BCF    1F.6
05CA:  BCF    03.5
05CB:  BCF    1F.6
05CC:  BCF    1F.7
05CD:  BSF    03.5
05CE:  BCF    1F.7
05CF:  BCF    03.5
05D0:  BSF    1F.0
....................    setup_psp(PSP_DISABLED); 
05D1:  BSF    03.5
05D2:  BCF    09.4
....................    setup_spi(SPI_SS_DISABLED); 
05D3:  BCF    03.5
05D4:  BCF    14.5
05D5:  BCF    22.5
05D6:  MOVF   22,W
05D7:  BSF    03.5
05D8:  MOVWF  07
05D9:  BCF    03.5
05DA:  BSF    22.4
05DB:  MOVF   22,W
05DC:  BSF    03.5
05DD:  MOVWF  07
05DE:  BCF    03.5
05DF:  BCF    22.3
05E0:  MOVF   22,W
05E1:  BSF    03.5
05E2:  MOVWF  07
05E3:  MOVLW  01
05E4:  BCF    03.5
05E5:  MOVWF  14
05E6:  MOVLW  00
05E7:  BSF    03.5
05E8:  MOVWF  14
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_1); 
05E9:  MOVF   01,W
05EA:  ANDLW  C7
05EB:  IORLW  08
05EC:  MOVWF  01
....................    setup_timer_1(T1_DISABLED); 
05ED:  BCF    03.5
05EE:  CLRF   10
....................    setup_timer_2(T2_DISABLED, 0, 1); 
05EF:  MOVLW  00
05F0:  MOVWF  78
05F1:  MOVWF  12
05F2:  MOVLW  00
05F3:  BSF    03.5
05F4:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC); 
05F5:  MOVLW  07
05F6:  MOVWF  1C
05F7:  MOVF   05,W
05F8:  MOVWF  05
05F9:  MOVLW  03
05FA:  MOVWF  77
05FB:  DECFSZ 77,F
05FC:  GOTO   5FB
05FD:  MOVF   1C,W
05FE:  BCF    03.5
05FF:  BCF    0D.6
....................    setup_vref(FALSE); 
0600:  BSF    03.5
0601:  CLRF   1D
....................    lcd_ini(); // Inicializa LCD 
0602:  BCF    03.5
0603:  GOTO   0C6
....................    delay_ms(10); 
0604:  MOVLW  0A
0605:  MOVWF  39
0606:  CALL   066
....................    init_ext_eeprom(); 
0607:  GOTO   107
....................    delay_ms(10); 
0608:  MOVLW  0A
0609:  MOVWF  39
060A:  CALL   066
....................  
....................    // Escrevendo a senha na memï¿½ria 
....................    write_ext_eeprom(0x1, '1'); 
060B:  CLRF   30
060C:  MOVLW  01
060D:  MOVWF  2F
060E:  MOVLW  31
060F:  MOVWF  31
0610:  CALL   199
....................    write_ext_eeprom(0x2, '2'); 
0611:  CLRF   30
0612:  MOVLW  02
0613:  MOVWF  2F
0614:  MOVLW  32
0615:  MOVWF  31
0616:  CALL   199
....................    write_ext_eeprom(0x3, '3'); 
0617:  CLRF   30
0618:  MOVLW  03
0619:  MOVWF  2F
061A:  MOVLW  33
061B:  MOVWF  31
061C:  CALL   199
....................    write_ext_eeprom(0x4, '4'); 
061D:  CLRF   30
061E:  MOVLW  04
061F:  MOVWF  2F
0620:  MOVLW  34
0621:  MOVWF  31
0622:  CALL   199
....................  
....................    int8 i; 
....................  
....................    for (i = 0; i < 4; i++) 
0623:  CLRF   2E
0624:  MOVF   2E,W
0625:  SUBLW  03
0626:  BTFSS  03.0
0627:  GOTO   62F
....................    { 
....................       senha[i] = 0; 
0628:  MOVLW  23
0629:  ADDWF  2E,W
062A:  MOVWF  04
062B:  BCF    03.7
062C:  CLRF   00
....................    } 
062D:  INCF   2E,F
062E:  GOTO   624
....................  
....................    while (true) 
....................    { 
....................       desenhaTelaInicial(); 
062F:  GOTO   269
....................       delay_ms(300); 
0630:  MOVLW  02
0631:  MOVWF  2F
0632:  MOVLW  96
0633:  MOVWF  39
0634:  CALL   066
0635:  DECFSZ 2F,F
0636:  GOTO   632
....................       tmp = tc_tecla(200); 
0637:  MOVLW  C8
0638:  MOVWF  2F
0639:  GOTO   281
063A:  MOVF   78,W
063B:  MOVWF  2D
....................  
....................       if (eTeclaValida(tmp)) 
063C:  MOVF   2D,W
063D:  MOVWF  2F
063E:  GOTO   3A9
063F:  MOVF   78,F
0640:  BTFSC  03.2
0641:  GOTO   667
....................       { 
....................          switch (tmp) 
....................          { 
0642:  MOVF   2D,W
0643:  XORLW  01
0644:  BTFSC  03.2
0645:  GOTO   64A
0646:  XORLW  03
0647:  BTFSC  03.2
0648:  GOTO   651
0649:  GOTO   655
....................          case 1: 
....................             desenhaTelaCadastrar(tmp, senha); 
064A:  MOVF   2D,W
064B:  MOVWF  2F
064C:  CLRF   31
064D:  MOVLW  23
064E:  MOVWF  30
064F:  GOTO   4A9
....................             break; 
0650:  GOTO   65D
....................          case 2: 
....................             desenhaTelaUtilizar(senha); 
0651:  CLRF   30
0652:  MOVLW  23
0653:  MOVWF  2F
0654:  GOTO   4CB
....................          default: 
....................             printf(lcd_escreve, "\fERRO DESCONHECIDO"); 
0655:  MOVLW  3D
0656:  BSF    03.6
0657:  MOVWF  0D
0658:  MOVLW  00
0659:  MOVWF  0F
065A:  BCF    03.6
065B:  CALL   223
....................             break; 
065C:  GOTO   65D
....................          } 
....................          senha[cont] = tmp; 
065D:  MOVLW  23
065E:  ADDWF  27,W
065F:  MOVWF  04
0660:  BCF    03.7
0661:  MOVF   2D,W
0662:  MOVWF  00
....................          cont++; 
0663:  INCF   27,F
....................          delay_ms(200); 
0664:  MOVLW  C8
0665:  MOVWF  39
0666:  CALL   066
....................       } 
....................  
....................       if (cont == 4) 
0667:  MOVF   27,W
0668:  SUBLW  04
0669:  BTFSS  03.2
066A:  GOTO   6DD
....................       { 
....................          for (i = 0; i < cont; i++) 
066B:  CLRF   2E
066C:  MOVF   27,W
066D:  SUBWF  2E,W
066E:  BTFSC  03.0
066F:  GOTO   6BE
....................          { 
....................             printf(lcd_escreve, "\fPosicao[%d]: %d", i + 1, read_ext_eeprom((int16)i + 1)); 
0670:  MOVLW  01
0671:  ADDWF  2E,W
0672:  MOVWF  2F
0673:  CLRF   31
0674:  MOVF   2E,W
0675:  MOVWF  30
0676:  MOVLW  01
0677:  ADDWF  30,F
0678:  BTFSC  03.0
0679:  INCF   31,F
067A:  MOVF   31,W
067B:  MOVWF  33
067C:  MOVF   30,W
067D:  MOVWF  32
067E:  CALL   4E1
067F:  MOVF   78,W
0680:  MOVWF  30
0681:  MOVLW  47
0682:  BSF    03.6
0683:  MOVWF  0D
0684:  MOVLW  00
0685:  MOVWF  0F
0686:  BCF    03.0
0687:  MOVLW  09
0688:  BCF    03.6
0689:  MOVWF  32
068A:  CALL   3CB
068B:  MOVF   2F,W
068C:  MOVWF  32
068D:  MOVLW  1F
068E:  MOVWF  33
068F:  CALL   42E
0690:  MOVLW  5D
0691:  MOVWF  38
0692:  CALL   1EB
0693:  MOVLW  3A
0694:  MOVWF  38
0695:  CALL   1EB
0696:  MOVLW  20
0697:  MOVWF  38
0698:  CALL   1EB
0699:  MOVF   30,W
069A:  MOVWF  32
069B:  MOVLW  1F
069C:  MOVWF  33
069D:  CALL   42E
....................             delay_ms(1000); 
069E:  MOVLW  04
069F:  MOVWF  2F
06A0:  MOVLW  FA
06A1:  MOVWF  39
06A2:  CALL   066
06A3:  DECFSZ 2F,F
06A4:  GOTO   6A0
....................             if (senha[i] != read_ext_eeprom((int16)i + 1)) 
06A5:  MOVLW  23
06A6:  ADDWF  2E,W
06A7:  MOVWF  04
06A8:  BCF    03.7
06A9:  MOVF   00,W
06AA:  MOVWF  2F
06AB:  CLRF   31
06AC:  MOVF   2E,W
06AD:  MOVWF  30
06AE:  MOVLW  01
06AF:  ADDWF  30,F
06B0:  BTFSC  03.0
06B1:  INCF   31,F
06B2:  MOVF   31,W
06B3:  MOVWF  33
06B4:  MOVF   30,W
06B5:  MOVWF  32
06B6:  CALL   4E1
06B7:  MOVF   78,W
06B8:  SUBWF  2F,W
06B9:  BTFSC  03.2
06BA:  GOTO   6BC
....................             { 
....................                senhaEstaCorreta = 0; 
06BB:  BCF    28.0
....................             } 
....................          } 
06BC:  INCF   2E,F
06BD:  GOTO   66C
....................          if (senhaEstaCorreta == 1) 
06BE:  BTFSS  28.0
06BF:  GOTO   6CF
....................          { 
....................             printf(lcd_escreve, "\fPARABENS PORTA\nABERTA!!"); 
06C0:  MOVLW  50
06C1:  BSF    03.6
06C2:  MOVWF  0D
06C3:  MOVLW  00
06C4:  MOVWF  0F
06C5:  BCF    03.6
06C6:  CALL   223
....................             delay_ms(10000); 
06C7:  MOVLW  28
06C8:  MOVWF  2F
06C9:  MOVLW  FA
06CA:  MOVWF  39
06CB:  CALL   066
06CC:  DECFSZ 2F,F
06CD:  GOTO   6C9
....................          } 
....................          else 
06CE:  GOTO   6DD
....................          { 
....................             printf(lcd_escreve, "\fSENHA INCORRETA!"); 
06CF:  MOVLW  5D
06D0:  BSF    03.6
06D1:  MOVWF  0D
06D2:  MOVLW  00
06D3:  MOVWF  0F
06D4:  BCF    03.6
06D5:  CALL   223
....................             delay_ms(10000); 
06D6:  MOVLW  28
06D7:  MOVWF  2F
06D8:  MOVLW  FA
06D9:  MOVWF  39
06DA:  CALL   066
06DB:  DECFSZ 2F,F
06DC:  GOTO   6D8
....................          } 
....................       } 
....................    } 
06DD:  GOTO   62F
.................... } 
06DE:  SLEEP

Configuration Fuses:
   Word  1: 3F79   XT NOWDT NOPUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
