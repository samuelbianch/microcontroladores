CCS PCM C Compiler, Version 4.104, 5967               19-out-23 16:59

               Filename: D:\Microcontroladores\Trabalho_Fechadura\main.lst

               ROM used: 1811 words (22%)
                         Largest free fragment is 2048
               RAM used: 18 (5%) at main() level
                         38 (10%) worst case
               Stack:    5 locations

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   567
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0572:  BCF    03.5
0573:  CLRF   20
0574:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... #ifndef STDBOOL_H 
.................... #define STDBOOL_h 
....................  
.................... #define bool _Bool 
.................... #ifndef true 
.................... #define true 1 
.................... #endif 
....................  
.................... #ifndef false 
.................... #define false 0 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // #device adc=8 
....................  
.................... #FUSES NOWDT     // No Watch Dog Timer 
.................... #FUSES XT        // High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT     // No Power Up Timer 
.................... #FUSES NOPROTECT // Code not protected from reading 
.................... #FUSES NODEBUG   // No Debug mode for ICD 
.................... #FUSES BROWNOUT  // Reset when brownout detected 
.................... #FUSES NOLVP     // No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD     // No EE protection 
.................... #FUSES NOWRT     // Program memory not write protected 
.................... #FUSES RESERVED  // Used to set the reserved FUSE bits 
....................  
.................... #use delay(clock = 4000000) 
*
00B2:  MOVLW  39
00B3:  MOVWF  04
00B4:  BCF    03.7
00B5:  MOVF   00,W
00B6:  BTFSC  03.2
00B7:  GOTO   0C6
00B8:  MOVLW  01
00B9:  MOVWF  78
00BA:  CLRF   77
00BB:  DECFSZ 77,F
00BC:  GOTO   0BB
00BD:  DECFSZ 78,F
00BE:  GOTO   0BA
00BF:  MOVLW  4A
00C0:  MOVWF  77
00C1:  DECFSZ 77,F
00C2:  GOTO   0C1
00C3:  GOTO   0C4
00C4:  DECFSZ 00,F
00C5:  GOTO   0B8
00C6:  RETURN
....................  
.................... #ifndef lcd_enable 
.................... #define lcd_enable pin_A3 // pino enable do LCD 
.................... #define lcd_rs pin_A5     // pino rs do LCD 
.................... #define lcd_rw pin_A4     // pino rw do LCD 
.................... #define lcd_d4 pin_d4     // pino de dados d4 do LCD 
.................... #define lcd_d5 pin_d5     // pino de dados d5 do LCD 
.................... #define lcd_d6 pin_d6     // pino de dados d6 do LCD 
.................... #define lcd_d7 pin_d7     // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulação de módulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fábio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variável de leitura 
.................... 	// lê os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dá um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lê os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
00C7:  BTFSC  40.0
00C8:  GOTO   0CB
00C9:  BCF    08.4
00CA:  GOTO   0CC
00CB:  BSF    08.4
00CC:  BSF    03.5
00CD:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
00CE:  BCF    03.5
00CF:  BTFSC  40.1
00D0:  GOTO   0D3
00D1:  BCF    08.5
00D2:  GOTO   0D4
00D3:  BSF    08.5
00D4:  BSF    03.5
00D5:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
00D6:  BCF    03.5
00D7:  BTFSC  40.2
00D8:  GOTO   0DB
00D9:  BCF    08.6
00DA:  GOTO   0DC
00DB:  BSF    08.6
00DC:  BSF    03.5
00DD:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
00DE:  BCF    03.5
00DF:  BTFSC  40.3
00E0:  GOTO   0E3
00E1:  BCF    08.7
00E2:  GOTO   0E4
00E3:  BSF    08.7
00E4:  BSF    03.5
00E5:  BCF    08.7
.................... 	// dá um pulso na linha enable 
.................... 	output_high(lcd_enable); 
00E6:  BCF    05.3
00E7:  BCF    03.5
00E8:  BSF    05.3
.................... 	output_low(lcd_enable); 
00E9:  BSF    03.5
00EA:  BCF    05.3
00EB:  BCF    03.5
00EC:  BCF    05.3
.................... } 
00ED:  RETURN
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
00EE:  BSF    03.5
00EF:  BCF    05.5
00F0:  BCF    03.5
00F1:  BCF    05.5
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
00F2:  MOVF   3D,F
00F3:  BTFSS  03.2
00F4:  GOTO   0F7
00F5:  BCF    05.5
00F6:  GOTO   0F8
00F7:  BSF    05.5
00F8:  BSF    03.5
00F9:  BCF    05.5
.................... 	delay_us(100);	// aguarda 100 us 
00FA:  MOVLW  21
00FB:  MOVWF  77
00FC:  DECFSZ 77,F
00FD:  GOTO   0FC
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
00FE:  BCF    05.4
00FF:  BCF    03.5
0100:  BCF    05.4
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
0101:  BSF    03.5
0102:  BCF    05.3
0103:  BCF    03.5
0104:  BCF    05.3
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
0105:  SWAPF  3E,W
0106:  MOVWF  3F
0107:  MOVLW  0F
0108:  ANDWF  3F,F
0109:  MOVF   3F,W
010A:  MOVWF  40
010B:  CALL   0C7
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
010C:  MOVF   3E,W
010D:  ANDLW  0F
010E:  MOVWF  3F
010F:  MOVWF  40
0110:  CALL   0C7
.................... } 
0111:  RETURN
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
0112:  BSF    03.5
0113:  BCF    08.4
0114:  BCF    03.5
0115:  BCF    08.4
.................... 	output_low(lcd_d5); 
0116:  BSF    03.5
0117:  BCF    08.5
0118:  BCF    03.5
0119:  BCF    08.5
.................... 	output_low(lcd_d6); 
011A:  BSF    03.5
011B:  BCF    08.6
011C:  BCF    03.5
011D:  BCF    08.6
.................... 	output_low(lcd_d7); 
011E:  BSF    03.5
011F:  BCF    08.7
0120:  BCF    03.5
0121:  BCF    08.7
.................... 	output_low(lcd_rs); 
0122:  BSF    03.5
0123:  BCF    05.5
0124:  BCF    03.5
0125:  BCF    05.5
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
0126:  BSF    03.5
0127:  BCF    05.4
0128:  BCF    03.5
0129:  BSF    05.4
.................... 	#endif 
.................... 	output_low(lcd_enable); 
012A:  BSF    03.5
012B:  BCF    05.3
012C:  BCF    03.5
012D:  BCF    05.3
.................... 	delay_ms(15); 
012E:  MOVLW  0F
012F:  MOVWF  39
0130:  CALL   0B2
.................... 	// envia uma seqüência de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o módulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
0131:  MOVLW  01
0132:  MOVWF  2E
0133:  MOVF   2E,W
0134:  SUBLW  03
0135:  BTFSS  03.0
0136:  GOTO   13F
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
0137:  MOVLW  03
0138:  MOVWF  40
0139:  CALL   0C7
.................... 		delay_ms(5); 
013A:  MOVLW  05
013B:  MOVWF  39
013C:  CALL   0B2
.................... 	} 
013D:  INCF   2E,F
013E:  GOTO   133
.................... 	lcd_envia_nibble(2); 
013F:  MOVLW  02
0140:  MOVWF  40
0141:  CALL   0C7
.................... 	// envia string de inicialização do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
0142:  CLRF   2E
0143:  MOVF   2E,W
0144:  SUBLW  03
0145:  BTFSS  03.0
0146:  GOTO   150
0147:  MOVF   2E,W
0148:  CALL   004
0149:  MOVWF  2F
014A:  CLRF   3D
014B:  MOVF   2F,W
014C:  MOVWF  3E
014D:  CALL   0EE
014E:  INCF   2E,F
014F:  GOTO   143
.................... } 
0150:  BCF    0A.3
0151:  BCF    0A.4
0152:  GOTO   5BA (RETURN)
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0251:  DECFSZ 3A,W
0252:  GOTO   254
0253:  GOTO   257
....................    	endereco = lcd_seg_lin; 
0254:  MOVLW  40
0255:  MOVWF  3B
....................    else 
0256:  GOTO   258
....................    	endereco = 0; 
0257:  CLRF   3B
....................    endereco += x-1; 
0258:  MOVLW  01
0259:  SUBWF  39,W
025A:  ADDWF  3B,F
....................    lcd_envia_byte(0,0x80|endereco); 
025B:  MOVF   3B,W
025C:  IORLW  80
025D:  MOVWF  3C
025E:  CLRF   3D
025F:  MOVF   3C,W
0260:  MOVWF  3E
0261:  CALL   0EE
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
.................... 	{ 
*
0237:  MOVF   38,W
0238:  XORLW  0C
0239:  BTFSC  03.2
023A:  GOTO   245
023B:  XORLW  06
023C:  BTFSC  03.2
023D:  GOTO   24D
023E:  XORLW  07
023F:  BTFSC  03.2
0240:  GOTO   24D
0241:  XORLW  05
0242:  BTFSC  03.2
0243:  GOTO   263
0244:  GOTO   268
....................      case '\f' 	:	lcd_envia_byte(0,1); 
0245:  CLRF   3D
0246:  MOVLW  01
0247:  MOVWF  3E
0248:  CALL   0EE
.................... 	  			delay_ms(2); 
0249:  MOVLW  02
024A:  MOVWF  39
024B:  CALL   0B2
.................... 				break; 
024C:  GOTO   26E
....................      case '\n'	: 
.................... 	 case '\r' 	:	lcd_pos_xy(1,2); 
024D:  MOVLW  01
024E:  MOVWF  39
024F:  MOVLW  02
0250:  MOVWF  3A
.................... 	  			break; 
*
0262:  GOTO   26E
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
0263:  CLRF   3D
0264:  MOVLW  10
0265:  MOVWF  3E
0266:  CALL   0EE
.................... 	  			break; 
0267:  GOTO   26E
....................      default	:	lcd_envia_byte(1,c); 
0268:  MOVLW  01
0269:  MOVWF  3D
026A:  MOVF   38,W
026B:  MOVWF  3E
026C:  CALL   0EE
.................... 	  			break; 
026D:  GOTO   26E
....................    } 
.................... } 
026E:  RETURN
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posição do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lê o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
.................... #include "kbd_ext_board2.c" 
.................... /*######################################################################  
....................  Rotina utilizaÃ§Ã£oo do teclado da placa PicSim board4 
....................  Adaptada para o compilador CCS 
....................  Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................  For e-mail suggestions : awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
.................... { 
*
02CD:  CLRF   2F
02CE:  CLRF   30
....................  unsigned int to=0; 
....................  unsigned char k = 0;  
....................  while(((to < timeout)||(!timeout))&&(!k)){ 
02CF:  MOVF   2E,W
02D0:  SUBWF  2F,W
02D1:  BTFSS  03.0
02D2:  GOTO   2D6
02D3:  MOVF   2E,F
02D4:  BTFSS  03.2
02D5:  GOTO   3EB
02D6:  MOVF   30,F
02D7:  BTFSS  03.2
02D8:  GOTO   3EB
....................   
....................   
....................  //------------------------------------------------------------------------- 
....................  //inicio do programa de varredura do teclado matricial 
....................  //-------------------------------------------------------------------------- 
....................  //habilita primeira coluna do teclado 
....................  output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
02D9:  BSF    03.5
02DA:  BCF    06.0
02DB:  BCF    03.5
02DC:  BCF    06.0
02DD:  BSF    03.5
02DE:  BCF    06.1
02DF:  BCF    03.5
02E0:  BSF    06.1
02E1:  BSF    03.5
02E2:  BCF    06.2
02E3:  BCF    03.5
02E4:  BSF    06.2
02E5:  BSF    03.5
02E6:  BCF    06.3
02E7:  BCF    03.5
02E8:  BSF    06.3
....................  delay_ms(20); 
02E9:  MOVLW  14
02EA:  MOVWF  39
02EB:  CALL   0B2
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
02EC:  BSF    03.5
02ED:  BSF    08.0
02EE:  BCF    03.5
02EF:  BTFSC  08.0
02F0:  GOTO   2F8
02F1:  BSF    03.5
02F2:  BSF    08.0
02F3:  BCF    03.5
02F4:  BTFSS  08.0
02F5:  GOTO   2F1
02F6:  MOVLW  31
02F7:  MOVWF  30
....................  if (input(PIN_D1) == 0){ 
02F8:  BSF    03.5
02F9:  BSF    08.1
02FA:  BCF    03.5
02FB:  BTFSC  08.1
02FC:  GOTO   304
....................  while(input(PIN_D1) == 0); 
02FD:  BSF    03.5
02FE:  BSF    08.1
02FF:  BCF    03.5
0300:  BTFSS  08.1
0301:  GOTO   2FD
....................  k='4'; 
0302:  MOVLW  34
0303:  MOVWF  30
....................  }; 
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
0304:  BSF    03.5
0305:  BSF    08.2
0306:  BCF    03.5
0307:  BTFSC  08.2
0308:  GOTO   310
0309:  BSF    03.5
030A:  BSF    08.2
030B:  BCF    03.5
030C:  BTFSS  08.2
030D:  GOTO   309
030E:  MOVLW  37
030F:  MOVWF  30
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
0310:  BSF    03.5
0311:  BSF    08.3
0312:  BCF    03.5
0313:  BTFSC  08.3
0314:  GOTO   31C
0315:  BSF    03.5
0316:  BSF    08.3
0317:  BCF    03.5
0318:  BTFSS  08.3
0319:  GOTO   315
031A:  MOVLW  2A
031B:  MOVWF  30
....................  //habilita segunda coluna do teclado 
....................  output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
031C:  BSF    03.5
031D:  BCF    06.0
031E:  BCF    03.5
031F:  BSF    06.0
0320:  BSF    03.5
0321:  BCF    06.1
0322:  BCF    03.5
0323:  BCF    06.1
0324:  BSF    03.5
0325:  BCF    06.2
0326:  BCF    03.5
0327:  BSF    06.2
0328:  BSF    03.5
0329:  BCF    06.3
032A:  BCF    03.5
032B:  BSF    06.3
....................  delay_ms(20);  
032C:  MOVLW  14
032D:  MOVWF  39
032E:  CALL   0B2
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
032F:  BSF    03.5
0330:  BSF    08.0
0331:  BCF    03.5
0332:  BTFSC  08.0
0333:  GOTO   33B
0334:  BSF    03.5
0335:  BSF    08.0
0336:  BCF    03.5
0337:  BTFSS  08.0
0338:  GOTO   334
0339:  MOVLW  32
033A:  MOVWF  30
....................  if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
033B:  BSF    03.5
033C:  BSF    08.1
033D:  BCF    03.5
033E:  BTFSC  08.1
033F:  GOTO   347
0340:  BSF    03.5
0341:  BSF    08.1
0342:  BCF    03.5
0343:  BTFSS  08.1
0344:  GOTO   340
0345:  MOVLW  35
0346:  MOVWF  30
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
0347:  BSF    03.5
0348:  BSF    08.2
0349:  BCF    03.5
034A:  BTFSC  08.2
034B:  GOTO   353
034C:  BSF    03.5
034D:  BSF    08.2
034E:  BCF    03.5
034F:  BTFSS  08.2
0350:  GOTO   34C
0351:  MOVLW  38
0352:  MOVWF  30
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
0353:  BSF    03.5
0354:  BSF    08.3
0355:  BCF    03.5
0356:  BTFSC  08.3
0357:  GOTO   35F
0358:  BSF    03.5
0359:  BSF    08.3
035A:  BCF    03.5
035B:  BTFSS  08.3
035C:  GOTO   358
035D:  MOVLW  30
035E:  MOVWF  30
....................   
....................  //habilita terceira coluna do teclado 
....................  output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
035F:  BSF    03.5
0360:  BCF    06.0
0361:  BCF    03.5
0362:  BSF    06.0
0363:  BSF    03.5
0364:  BCF    06.1
0365:  BCF    03.5
0366:  BSF    06.1
0367:  BSF    03.5
0368:  BCF    06.2
0369:  BCF    03.5
036A:  BCF    06.2
036B:  BSF    03.5
036C:  BCF    06.3
036D:  BCF    03.5
036E:  BSF    06.3
....................  delay_ms(20);  
036F:  MOVLW  14
0370:  MOVWF  39
0371:  CALL   0B2
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
0372:  BSF    03.5
0373:  BSF    08.0
0374:  BCF    03.5
0375:  BTFSC  08.0
0376:  GOTO   37E
0377:  BSF    03.5
0378:  BSF    08.0
0379:  BCF    03.5
037A:  BTFSS  08.0
037B:  GOTO   377
037C:  MOVLW  33
037D:  MOVWF  30
....................  if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
037E:  BSF    03.5
037F:  BSF    08.1
0380:  BCF    03.5
0381:  BTFSC  08.1
0382:  GOTO   38A
0383:  BSF    03.5
0384:  BSF    08.1
0385:  BCF    03.5
0386:  BTFSS  08.1
0387:  GOTO   383
0388:  MOVLW  36
0389:  MOVWF  30
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
038A:  BSF    03.5
038B:  BSF    08.2
038C:  BCF    03.5
038D:  BTFSC  08.2
038E:  GOTO   396
038F:  BSF    03.5
0390:  BSF    08.2
0391:  BCF    03.5
0392:  BTFSS  08.2
0393:  GOTO   38F
0394:  MOVLW  39
0395:  MOVWF  30
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
0396:  BSF    03.5
0397:  BSF    08.3
0398:  BCF    03.5
0399:  BTFSC  08.3
039A:  GOTO   3A2
039B:  BSF    03.5
039C:  BSF    08.3
039D:  BCF    03.5
039E:  BTFSS  08.3
039F:  GOTO   39B
03A0:  MOVLW  23
03A1:  MOVWF  30
....................  //habilita quarta coluna do teclado 
....................  output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
03A2:  BSF    03.5
03A3:  BCF    06.0
03A4:  BCF    03.5
03A5:  BSF    06.0
03A6:  BSF    03.5
03A7:  BCF    06.1
03A8:  BCF    03.5
03A9:  BSF    06.1
03AA:  BSF    03.5
03AB:  BCF    06.2
03AC:  BCF    03.5
03AD:  BSF    06.2
03AE:  BSF    03.5
03AF:  BCF    06.3
03B0:  BCF    03.5
03B1:  BCF    06.3
....................  delay_ms(20);  
03B2:  MOVLW  14
03B3:  MOVWF  39
03B4:  CALL   0B2
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
03B5:  BSF    03.5
03B6:  BSF    08.0
03B7:  BCF    03.5
03B8:  BTFSC  08.0
03B9:  GOTO   3C1
03BA:  BSF    03.5
03BB:  BSF    08.0
03BC:  BCF    03.5
03BD:  BTFSS  08.0
03BE:  GOTO   3BA
03BF:  MOVLW  41
03C0:  MOVWF  30
....................  if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
03C1:  BSF    03.5
03C2:  BSF    08.1
03C3:  BCF    03.5
03C4:  BTFSC  08.1
03C5:  GOTO   3CD
03C6:  BSF    03.5
03C7:  BSF    08.1
03C8:  BCF    03.5
03C9:  BTFSS  08.1
03CA:  GOTO   3C6
03CB:  MOVLW  42
03CC:  MOVWF  30
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
03CD:  BSF    03.5
03CE:  BSF    08.2
03CF:  BCF    03.5
03D0:  BTFSC  08.2
03D1:  GOTO   3D9
03D2:  BSF    03.5
03D3:  BSF    08.2
03D4:  BCF    03.5
03D5:  BTFSS  08.2
03D6:  GOTO   3D2
03D7:  MOVLW  43
03D8:  MOVWF  30
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
03D9:  BSF    03.5
03DA:  BSF    08.3
03DB:  BCF    03.5
03DC:  BTFSC  08.3
03DD:  GOTO   3E5
03DE:  BSF    03.5
03DF:  BSF    08.3
03E0:  BCF    03.5
03E1:  BTFSS  08.3
03E2:  GOTO   3DE
03E3:  MOVLW  44
03E4:  MOVWF  30
....................   
....................  delay_ms(5); 
03E5:  MOVLW  05
03E6:  MOVWF  39
03E7:  CALL   0B2
....................  to+=5; 
03E8:  MOVLW  05
03E9:  ADDWF  2F,F
....................  } 
03EA:  GOTO   2CF
....................  if(!k)k=255; 
03EB:  MOVF   30,F
03EC:  BTFSS  03.2
03ED:  GOTO   3F0
03EE:  MOVLW  FF
03EF:  MOVWF  30
....................  return k;  
03F0:  MOVF   30,W
03F1:  MOVWF  78
.................... } 
03F2:  RETURN
....................  
.................... #include "2408.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC08B                                 //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0160:  MOVLW  08
0161:  MOVWF  78
0162:  NOP
0163:  BCF    07.3
0164:  BCF    22.3
0165:  MOVF   22,W
0166:  BSF    03.5
0167:  MOVWF  07
0168:  NOP
0169:  BCF    03.5
016A:  RLF    3C,F
016B:  BCF    07.4
016C:  BTFSS  03.0
016D:  GOTO   174
016E:  BSF    22.4
016F:  MOVF   22,W
0170:  BSF    03.5
0171:  MOVWF  07
0172:  GOTO   178
0173:  BCF    03.5
0174:  BCF    22.4
0175:  MOVF   22,W
0176:  BSF    03.5
0177:  MOVWF  07
0178:  NOP
0179:  BCF    03.5
017A:  BSF    22.3
017B:  MOVF   22,W
017C:  BSF    03.5
017D:  MOVWF  07
017E:  BCF    03.5
017F:  BTFSS  07.3
0180:  GOTO   17F
0181:  DECFSZ 78,F
0182:  GOTO   162
0183:  NOP
0184:  BCF    07.3
0185:  BCF    22.3
0186:  MOVF   22,W
0187:  BSF    03.5
0188:  MOVWF  07
0189:  NOP
018A:  BCF    03.5
018B:  BSF    22.4
018C:  MOVF   22,W
018D:  BSF    03.5
018E:  MOVWF  07
018F:  NOP
0190:  NOP
0191:  BCF    03.5
0192:  BSF    22.3
0193:  MOVF   22,W
0194:  BSF    03.5
0195:  MOVWF  07
0196:  BCF    03.5
0197:  BTFSS  07.3
0198:  GOTO   197
0199:  CLRF   78
019A:  NOP
019B:  BTFSC  07.4
019C:  BSF    78.0
019D:  BCF    07.3
019E:  BCF    22.3
019F:  MOVF   22,W
01A0:  BSF    03.5
01A1:  MOVWF  07
01A2:  BCF    03.5
01A3:  BCF    07.4
01A4:  BCF    22.4
01A5:  MOVF   22,W
01A6:  BSF    03.5
01A7:  MOVWF  07
01A8:  BCF    03.5
01A9:  RETURN
*
047F:  MOVLW  08
0480:  MOVWF  3C
0481:  MOVF   77,W
0482:  MOVWF  3D
0483:  BSF    22.4
0484:  MOVF   22,W
0485:  BSF    03.5
0486:  MOVWF  07
0487:  NOP
0488:  BCF    03.5
0489:  BSF    22.3
048A:  MOVF   22,W
048B:  BSF    03.5
048C:  MOVWF  07
048D:  BCF    03.5
048E:  BTFSS  07.3
048F:  GOTO   48E
0490:  BTFSC  07.4
0491:  BSF    03.0
0492:  BTFSS  07.4
0493:  BCF    03.0
0494:  RLF    78,F
0495:  NOP
0496:  BCF    22.3
0497:  MOVF   22,W
0498:  BSF    03.5
0499:  MOVWF  07
049A:  BCF    03.5
049B:  BCF    07.3
049C:  DECFSZ 3C,F
049D:  GOTO   483
049E:  BSF    22.4
049F:  MOVF   22,W
04A0:  BSF    03.5
04A1:  MOVWF  07
04A2:  NOP
04A3:  BCF    03.5
04A4:  BCF    07.4
04A5:  MOVF   3D,W
04A6:  BTFSC  03.2
04A7:  GOTO   4AD
04A8:  BCF    22.4
04A9:  MOVF   22,W
04AA:  BSF    03.5
04AB:  MOVWF  07
04AC:  BCF    03.5
04AD:  NOP
04AE:  BSF    22.3
04AF:  MOVF   22,W
04B0:  BSF    03.5
04B1:  MOVWF  07
04B2:  BCF    03.5
04B3:  BTFSS  07.3
04B4:  GOTO   4B3
04B5:  NOP
04B6:  BCF    07.3
04B7:  BCF    22.3
04B8:  MOVF   22,W
04B9:  BSF    03.5
04BA:  MOVWF  07
04BB:  NOP
04BC:  BCF    03.5
04BD:  BCF    07.4
04BE:  BCF    22.4
04BF:  MOVF   22,W
04C0:  BSF    03.5
04C1:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE    1024 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0153:  BSF    22.3
0154:  MOVF   22,W
0155:  BSF    03.5
0156:  MOVWF  07
....................    output_float(EEPROM_SDA); 
0157:  BCF    03.5
0158:  BSF    22.4
0159:  MOVF   22,W
015A:  BSF    03.5
015B:  MOVWF  07
.................... } 
015C:  BCF    03.5
015D:  BCF    0A.3
015E:  BCF    0A.4
015F:  GOTO   5BE (RETURN)
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
01AA:  BSF    22.4
01AB:  MOVF   22,W
01AC:  BSF    03.5
01AD:  MOVWF  07
01AE:  NOP
01AF:  BCF    03.5
01B0:  BSF    22.3
01B1:  MOVF   22,W
01B2:  BSF    03.5
01B3:  MOVWF  07
01B4:  NOP
01B5:  BCF    03.5
01B6:  BCF    07.4
01B7:  BCF    22.4
01B8:  MOVF   22,W
01B9:  BSF    03.5
01BA:  MOVWF  07
01BB:  NOP
01BC:  BCF    03.5
01BD:  BCF    07.3
01BE:  BCF    22.3
01BF:  MOVF   22,W
01C0:  BSF    03.5
01C1:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
01C2:  MOVLW  A0
01C3:  BCF    03.5
01C4:  MOVWF  3C
01C5:  CALL   160
01C6:  MOVF   78,W
01C7:  BCF    3B.0
01C8:  BTFSC  78.0
01C9:  BSF    3B.0
....................    i2c_stop(); 
01CA:  BCF    22.4
01CB:  MOVF   22,W
01CC:  BSF    03.5
01CD:  MOVWF  07
01CE:  NOP
01CF:  BCF    03.5
01D0:  BSF    22.3
01D1:  MOVF   22,W
01D2:  BSF    03.5
01D3:  MOVWF  07
01D4:  BCF    03.5
01D5:  BTFSS  07.3
01D6:  GOTO   1D5
01D7:  NOP
01D8:  GOTO   1D9
01D9:  NOP
01DA:  BSF    22.4
01DB:  MOVF   22,W
01DC:  BSF    03.5
01DD:  MOVWF  07
01DE:  NOP
....................    return !ack; 
01DF:  MOVLW  00
01E0:  BCF    03.5
01E1:  BTFSS  3B.0
01E2:  MOVLW  01
01E3:  MOVWF  78
.................... } 
01E4:  RETURN
....................  
.................... void write_ext_eeprom(long int address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
01E5:  CALL   1AA
01E6:  MOVF   78,F
01E7:  BTFSC  03.2
01E8:  GOTO   1E5
....................    i2c_start(); 
01E9:  BSF    22.4
01EA:  MOVF   22,W
01EB:  BSF    03.5
01EC:  MOVWF  07
01ED:  NOP
01EE:  BCF    03.5
01EF:  BSF    22.3
01F0:  MOVF   22,W
01F1:  BSF    03.5
01F2:  MOVWF  07
01F3:  NOP
01F4:  BCF    03.5
01F5:  BCF    07.4
01F6:  BCF    22.4
01F7:  MOVF   22,W
01F8:  BSF    03.5
01F9:  MOVWF  07
01FA:  NOP
01FB:  BCF    03.5
01FC:  BCF    07.3
01FD:  BCF    22.3
01FE:  MOVF   22,W
01FF:  BSF    03.5
0200:  MOVWF  07
....................    i2c_write((0xa0|(BYTE)(address>>7))&0xfe); 
0201:  BCF    03.5
0202:  RRF    2F,W
0203:  MOVWF  7A
0204:  RRF    2E,W
0205:  MOVWF  79
0206:  RRF    7A,F
0207:  RRF    79,F
0208:  RRF    7A,F
0209:  RRF    79,F
020A:  RRF    7A,F
020B:  RRF    79,F
020C:  RRF    7A,F
020D:  RRF    79,F
020E:  RRF    7A,F
020F:  RRF    79,F
0210:  RRF    7A,F
0211:  RRF    79,F
0212:  MOVLW  01
0213:  ANDWF  7A,F
0214:  MOVF   79,W
0215:  IORLW  A0
0216:  ANDLW  FE
0217:  MOVWF  31
0218:  MOVWF  3C
0219:  CALL   160
....................    i2c_write(address); 
021A:  MOVF   2E,W
021B:  MOVWF  3C
021C:  CALL   160
....................    i2c_write(data); 
021D:  MOVF   30,W
021E:  MOVWF  3C
021F:  CALL   160
....................    i2c_stop(); 
0220:  BCF    22.4
0221:  MOVF   22,W
0222:  BSF    03.5
0223:  MOVWF  07
0224:  NOP
0225:  BCF    03.5
0226:  BSF    22.3
0227:  MOVF   22,W
0228:  BSF    03.5
0229:  MOVWF  07
022A:  BCF    03.5
022B:  BTFSS  07.3
022C:  GOTO   22B
022D:  NOP
022E:  GOTO   22F
022F:  NOP
0230:  BSF    22.4
0231:  MOVF   22,W
0232:  BSF    03.5
0233:  MOVWF  07
0234:  NOP
.................... } 
0235:  BCF    03.5
0236:  RETURN
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
0413:  CALL   1AA
0414:  MOVF   78,F
0415:  BTFSC  03.2
0416:  GOTO   413
....................    i2c_start(); 
0417:  BSF    22.4
0418:  MOVF   22,W
0419:  BSF    03.5
041A:  MOVWF  07
041B:  NOP
041C:  BCF    03.5
041D:  BSF    22.3
041E:  MOVF   22,W
041F:  BSF    03.5
0420:  MOVWF  07
0421:  NOP
0422:  BCF    03.5
0423:  BCF    07.4
0424:  BCF    22.4
0425:  MOVF   22,W
0426:  BSF    03.5
0427:  MOVWF  07
0428:  NOP
0429:  BCF    03.5
042A:  BCF    07.3
042B:  BCF    22.3
042C:  MOVF   22,W
042D:  BSF    03.5
042E:  MOVWF  07
....................    i2c_write((0xa0|(BYTE)(address>>7))&0xfe); 
042F:  BCF    03.5
0430:  RRF    39,W
0431:  MOVWF  7A
0432:  RRF    38,W
0433:  MOVWF  79
0434:  RRF    7A,F
0435:  RRF    79,F
0436:  RRF    7A,F
0437:  RRF    79,F
0438:  RRF    7A,F
0439:  RRF    79,F
043A:  RRF    7A,F
043B:  RRF    79,F
043C:  RRF    7A,F
043D:  RRF    79,F
043E:  RRF    7A,F
043F:  RRF    79,F
0440:  MOVLW  01
0441:  ANDWF  7A,F
0442:  MOVF   79,W
0443:  IORLW  A0
0444:  ANDLW  FE
0445:  MOVWF  3B
0446:  MOVWF  3C
0447:  CALL   160
....................    i2c_write(address); 
0448:  MOVF   38,W
0449:  MOVWF  3C
044A:  CALL   160
....................    i2c_start(); 
044B:  BSF    22.4
044C:  MOVF   22,W
044D:  BSF    03.5
044E:  MOVWF  07
044F:  NOP
0450:  BCF    03.5
0451:  BSF    22.3
0452:  MOVF   22,W
0453:  BSF    03.5
0454:  MOVWF  07
0455:  NOP
0456:  BCF    03.5
0457:  BTFSS  07.3
0458:  GOTO   457
0459:  BCF    07.4
045A:  BCF    22.4
045B:  MOVF   22,W
045C:  BSF    03.5
045D:  MOVWF  07
045E:  NOP
045F:  BCF    03.5
0460:  BCF    07.3
0461:  BCF    22.3
0462:  MOVF   22,W
0463:  BSF    03.5
0464:  MOVWF  07
....................    i2c_write((0xa0|(BYTE)(address>>7))|1); 
0465:  BCF    03.5
0466:  RRF    39,W
0467:  MOVWF  7A
0468:  RRF    38,W
0469:  MOVWF  79
046A:  RRF    7A,F
046B:  RRF    79,F
046C:  RRF    7A,F
046D:  RRF    79,F
046E:  RRF    7A,F
046F:  RRF    79,F
0470:  RRF    7A,F
0471:  RRF    79,F
0472:  RRF    7A,F
0473:  RRF    79,F
0474:  RRF    7A,F
0475:  RRF    79,F
0476:  MOVLW  01
0477:  ANDWF  7A,F
0478:  MOVF   79,W
0479:  IORLW  A0
047A:  IORLW  01
047B:  MOVWF  3B
047C:  MOVWF  3C
047D:  CALL   160
....................    data=i2c_read(0); 
047E:  CLRF   77
*
04C2:  MOVF   78,W
04C3:  BCF    03.5
04C4:  MOVWF  3A
....................    i2c_stop(); 
04C5:  BCF    22.4
04C6:  MOVF   22,W
04C7:  BSF    03.5
04C8:  MOVWF  07
04C9:  NOP
04CA:  BCF    03.5
04CB:  BSF    22.3
04CC:  MOVF   22,W
04CD:  BSF    03.5
04CE:  MOVWF  07
04CF:  BCF    03.5
04D0:  BTFSS  07.3
04D1:  GOTO   4D0
04D2:  NOP
04D3:  GOTO   4D4
04D4:  NOP
04D5:  BSF    22.4
04D6:  MOVF   22,W
04D7:  BSF    03.5
04D8:  MOVWF  07
04D9:  NOP
....................    return(data); 
04DA:  BCF    03.5
04DB:  MOVF   3A,W
04DC:  MOVWF  78
.................... } 
04DD:  RETURN
....................  
....................  
.................... long int End_HL(byte H, byte L) 
.................... { 
....................    return (H << 8) + L; 
.................... } 
....................  
.................... char *IntToHex(int value) 
.................... { 
....................    int a; 
....................    int b; 
....................    char *buffer; 
....................  
....................    a = value && 16; 
....................    b = (value >> 4) & 16; 
....................    buffer[0] = (a < 10) ? '0' + a : 'A' - (a - 10); 
....................    buffer[1] = (b < 10) ? '0' + b : 'A' - (b - 10); 
....................  
....................    return buffer; 
.................... } 
....................  
.................... void WRITE_FLOAT_EXT_EEPROM(long int n, float data) 
.................... { 
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
....................       write_ext_eeprom(i + n, *((int8 *)&data + i)); 
.................... } 
....................  
.................... float READ_FLOAT_EXT_EEPROM(long int n) 
.................... { 
....................    int i; 
....................    float data; 
....................  
....................    for (i = 0; i < 4; i++) 
....................       *((int8 *)&data + i) = read_ext_eeprom(i + n); 
....................  
....................    return ((float)data); 
.................... } 
....................  
.................... void eeprom_int16(unsigned int endereco, int16 valor_i16) 
.................... { 
....................    write_ext_eeprom(endereco, make8(valor_i16, 0)); 
....................    write_ext_eeprom(endereco + 1, make8(valor_i16, 1)); 
.................... } 
....................  
.................... int1 eTeclaValida(char c) 
.................... { 
....................    if (((int)c >= 48 && (int)c <= 57) || ((int)c >= 65 && (int)c <= 68) || ((int)c == 42 || (int)c == 35)) 
*
03F3:  MOVF   2E,W
03F4:  SUBLW  2F
03F5:  BTFSC  03.0
03F6:  GOTO   3FB
03F7:  MOVF   2E,W
03F8:  SUBLW  39
03F9:  BTFSC  03.0
03FA:  GOTO   40B
03FB:  MOVF   2E,W
03FC:  SUBLW  40
03FD:  BTFSC  03.0
03FE:  GOTO   403
03FF:  MOVF   2E,W
0400:  SUBLW  44
0401:  BTFSC  03.0
0402:  GOTO   40B
0403:  MOVF   2E,W
0404:  SUBLW  2A
0405:  BTFSC  03.2
0406:  GOTO   40B
0407:  MOVF   2E,W
0408:  SUBLW  23
0409:  BTFSS  03.2
040A:  GOTO   40F
....................       return 1; 
040B:  MOVLW  01
040C:  MOVWF  78
040D:  GOTO   412
....................    else 
040E:  GOTO   412
....................       return 0; 
040F:  MOVLW  00
0410:  MOVWF  78
0411:  GOTO   412
.................... } 
0412:  RETURN
....................  
.................... void desenhaTelaInicial() 
.................... { 
....................    printf(lcd_escreve, "\fSeja bem vindo!"); 
*
02B5:  MOVLW  0C
02B6:  BSF    03.6
02B7:  MOVWF  0D
02B8:  MOVLW  00
02B9:  MOVWF  0F
02BA:  BCF    03.6
02BB:  CALL   26F
....................    delay_ms(1000); 
02BC:  MOVLW  04
02BD:  MOVWF  2E
02BE:  MOVLW  FA
02BF:  MOVWF  39
02C0:  CALL   0B2
02C1:  DECFSZ 2E,F
02C2:  GOTO   2BE
....................    printf(lcd_escreve, "\f1 - Cadastrar\n2 - Utilizar"); 
02C3:  MOVLW  15
02C4:  BSF    03.6
02C5:  MOVWF  0D
02C6:  MOVLW  00
02C7:  MOVWF  0F
02C8:  BCF    03.6
02C9:  CALL   26F
.................... } 
02CA:  BCF    0A.3
02CB:  BCF    0A.4
02CC:  GOTO   5EA (RETURN)
....................  
.................... void desenhaTelaCadastrar(int userID, char senha[]) 
.................... { 
....................    printf(lcd_escreve, "\fID User: %d\nSenha: %s", userID, senha); 
.................... } 
....................  
.................... void confereSenha(char user, char senha[]) 
.................... { 
*
005A:  DATA 00,00
*
04DE:  BCF    32.0
04DF:  BCF    32.1
....................    int8 c; 
....................    int1 senhaEstaCorreta = 0, userExiste = 0; 
....................    int16 j; 
....................    for (j = 0; j < 1024; j = j + 5) 
04E0:  CLRF   34
04E1:  CLRF   33
04E2:  MOVF   34,W
04E3:  SUBLW  03
04E4:  BTFSS  03.0
04E5:  GOTO   51F
....................    { 
....................       if (user == read_ext_eeprom((int16)j)) 
04E6:  MOVF   34,W
04E7:  MOVWF  39
04E8:  MOVF   33,W
04E9:  MOVWF  38
04EA:  CALL   413
04EB:  MOVF   78,W
04EC:  SUBWF  2E,W
04ED:  BTFSS  03.2
04EE:  GOTO   51A
....................       { 
....................          userExiste = 1; 
04EF:  BSF    32.1
....................          for (c = j + 1; c < j + 5; c++) 
04F0:  MOVLW  01
04F1:  ADDWF  33,W
04F2:  MOVWF  31
04F3:  MOVLW  05
04F4:  ADDWF  33,W
04F5:  MOVWF  78
04F6:  MOVF   34,W
04F7:  MOVWF  7A
04F8:  BTFSC  03.0
04F9:  INCF   7A,F
04FA:  MOVF   78,W
04FB:  MOVF   7A,F
04FC:  BTFSS  03.2
04FD:  GOTO   502
04FE:  MOVF   78,W
04FF:  SUBWF  31,W
0500:  BTFSC  03.0
0501:  GOTO   51A
....................          { 
....................             if (senha[j] == read_ext_eeprom((int16)c)) 
0502:  MOVF   2F,W
0503:  ADDWF  33,W
0504:  MOVWF  04
0505:  BCF    03.7
0506:  BTFSC  30.0
0507:  BSF    03.7
0508:  MOVF   00,W
0509:  MOVWF  35
050A:  CLRF   37
050B:  MOVF   31,W
050C:  MOVWF  36
050D:  MOVF   37,W
050E:  MOVWF  39
050F:  MOVF   36,W
0510:  MOVWF  38
0511:  CALL   413
0512:  MOVF   78,W
0513:  SUBWF  35,W
0514:  BTFSS  03.2
0515:  GOTO   518
....................             { 
....................                senhaEstaCorreta = 1; 
0516:  BSF    32.0
....................                break; 
0517:  GOTO   51A
....................             } 
....................          } 
0518:  INCF   31,F
0519:  GOTO   4F3
....................       } 
....................    } 
051A:  MOVLW  05
051B:  ADDWF  33,F
051C:  BTFSC  03.0
051D:  INCF   34,F
051E:  GOTO   4E2
....................  
....................    if (senhaEstaCorreta == 1 && userExiste == 1) 
051F:  BTFSS  32.0
0520:  GOTO   532
0521:  BTFSS  32.1
0522:  GOTO   532
....................    { 
....................       printf(lcd_escreve, "\fPARABENS PORTA\nABERTA!!"); 
0523:  MOVLW  2F
0524:  BSF    03.6
0525:  MOVWF  0D
0526:  MOVLW  00
0527:  MOVWF  0F
0528:  BCF    03.6
0529:  CALL   26F
....................       delay_ms(3000); 
052A:  MOVLW  0C
052B:  MOVWF  35
052C:  MOVLW  FA
052D:  MOVWF  39
052E:  CALL   0B2
052F:  DECFSZ 35,F
0530:  GOTO   52C
....................    } 
....................    else if (userExiste == 0) 
0531:  GOTO   564
0532:  BTFSC  32.1
0533:  GOTO   543
....................    { 
....................       printf(lcd_escreve, "\fUsuario Nao\nExiste!"); 
0534:  MOVLW  3C
0535:  BSF    03.6
0536:  MOVWF  0D
0537:  MOVLW  00
0538:  MOVWF  0F
0539:  BCF    03.6
053A:  CALL   26F
....................       delay_ms(3000); 
053B:  MOVLW  0C
053C:  MOVWF  35
053D:  MOVLW  FA
053E:  MOVWF  39
053F:  CALL   0B2
0540:  DECFSZ 35,F
0541:  GOTO   53D
....................    } 
....................    else if (userExiste == 1 && senhaEstaCorreta == 0) 
0542:  GOTO   564
0543:  BTFSS  32.1
0544:  GOTO   556
0545:  BTFSC  32.0
0546:  GOTO   556
....................    { 
....................       printf(lcd_escreve, "\fUSenha Invalida!"); 
0547:  MOVLW  47
0548:  BSF    03.6
0549:  MOVWF  0D
054A:  MOVLW  00
054B:  MOVWF  0F
054C:  BCF    03.6
054D:  CALL   26F
....................       delay_ms(3000); 
054E:  MOVLW  0C
054F:  MOVWF  35
0550:  MOVLW  FA
0551:  MOVWF  39
0552:  CALL   0B2
0553:  DECFSZ 35,F
0554:  GOTO   550
....................    } 
....................    else 
0555:  GOTO   564
....................    { 
....................       printf(lcd_escreve, "\fERRO AO\nAUTENTICAR!"); 
0556:  MOVLW  50
0557:  BSF    03.6
0558:  MOVWF  0D
0559:  MOVLW  00
055A:  MOVWF  0F
055B:  BCF    03.6
055C:  CALL   26F
....................       delay_ms(3000); 
055D:  MOVLW  0C
055E:  MOVWF  35
055F:  MOVLW  FA
0560:  MOVWF  39
0561:  CALL   0B2
0562:  DECFSZ 35,F
0563:  GOTO   55F
....................    } 
.................... } 
0564:  BCF    0A.3
0565:  BCF    0A.4
0566:  GOTO   711 (RETURN)
....................  
.................... void main() 
.................... { 
*
00B1:  DATA 00,00
*
0567:  CLRF   04
0568:  BCF    03.7
0569:  MOVLW  1F
056A:  ANDWF  03,F
056B:  BSF    03.5
056C:  BSF    1F.0
056D:  BSF    1F.1
056E:  BSF    1F.2
056F:  BCF    1F.3
0570:  MOVLW  07
0571:  MOVWF  1C
*
0578:  CLRF   2A
0579:  CLRF   29
....................    char senha[4] = ""; 
*
0577:  CLRF   23
....................    char tmp, user; 
....................    int16 posMemoria = 0; 
....................  
....................    setup_adc_ports(AN0); 
*
057A:  BSF    03.5
057B:  BCF    1F.0
057C:  BSF    1F.1
057D:  BSF    1F.2
057E:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_DIV_2); 
057F:  BCF    1F.6
0580:  BCF    03.5
0581:  BCF    1F.6
0582:  BCF    1F.7
0583:  BSF    03.5
0584:  BCF    1F.7
0585:  BCF    03.5
0586:  BSF    1F.0
....................    setup_psp(PSP_DISABLED); 
0587:  BSF    03.5
0588:  BCF    09.4
....................    setup_spi(SPI_SS_DISABLED); 
0589:  BCF    03.5
058A:  BCF    14.5
058B:  BCF    22.5
058C:  MOVF   22,W
058D:  BSF    03.5
058E:  MOVWF  07
058F:  BCF    03.5
0590:  BSF    22.4
0591:  MOVF   22,W
0592:  BSF    03.5
0593:  MOVWF  07
0594:  BCF    03.5
0595:  BCF    22.3
0596:  MOVF   22,W
0597:  BSF    03.5
0598:  MOVWF  07
0599:  MOVLW  01
059A:  BCF    03.5
059B:  MOVWF  14
059C:  MOVLW  00
059D:  BSF    03.5
059E:  MOVWF  14
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_1); 
059F:  MOVF   01,W
05A0:  ANDLW  C7
05A1:  IORLW  08
05A2:  MOVWF  01
....................    setup_timer_1(T1_DISABLED); 
05A3:  BCF    03.5
05A4:  CLRF   10
....................    setup_timer_2(T2_DISABLED, 0, 1); 
05A5:  MOVLW  00
05A6:  MOVWF  78
05A7:  MOVWF  12
05A8:  MOVLW  00
05A9:  BSF    03.5
05AA:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC); 
05AB:  MOVLW  07
05AC:  MOVWF  1C
05AD:  MOVF   05,W
05AE:  MOVWF  05
05AF:  MOVLW  03
05B0:  MOVWF  77
05B1:  DECFSZ 77,F
05B2:  GOTO   5B1
05B3:  MOVF   1C,W
05B4:  BCF    03.5
05B5:  BCF    0D.6
....................    setup_vref(FALSE); 
05B6:  BSF    03.5
05B7:  CLRF   1D
....................    lcd_ini(); // Inicializa LCD 
05B8:  BCF    03.5
05B9:  GOTO   112
....................    delay_ms(10); 
05BA:  MOVLW  0A
05BB:  MOVWF  39
05BC:  CALL   0B2
....................    init_ext_eeprom(); 
05BD:  GOTO   153
....................    delay_ms(10); 
05BE:  MOVLW  0A
05BF:  MOVWF  39
05C0:  CALL   0B2
....................  
....................    // Grava ID e senha do Admin 
....................    write_ext_eeprom(0x0, 0); 
05C1:  CLRF   2F
05C2:  CLRF   2E
05C3:  CLRF   30
05C4:  CALL   1E5
....................    write_ext_eeprom(0x1, '0'); 
05C5:  CLRF   2F
05C6:  MOVLW  01
05C7:  MOVWF  2E
05C8:  MOVLW  30
05C9:  MOVWF  30
05CA:  CALL   1E5
....................    write_ext_eeprom(0x2, '0'); 
05CB:  CLRF   2F
05CC:  MOVLW  02
05CD:  MOVWF  2E
05CE:  MOVLW  30
05CF:  MOVWF  30
05D0:  CALL   1E5
....................    write_ext_eeprom(0x3, '0'); 
05D1:  CLRF   2F
05D2:  MOVLW  03
05D3:  MOVWF  2E
05D4:  MOVLW  30
05D5:  MOVWF  30
05D6:  CALL   1E5
....................    write_ext_eeprom(0x4, '0'); 
05D7:  CLRF   2F
05D8:  MOVLW  04
05D9:  MOVWF  2E
05DA:  MOVLW  30
05DB:  MOVWF  30
05DC:  CALL   1E5
....................  
....................    int8 i; 
....................    int16 j; 
....................    for (i = 0; i < 4; i++) 
05DD:  CLRF   2B
05DE:  MOVF   2B,W
05DF:  SUBLW  03
05E0:  BTFSS  03.0
05E1:  GOTO   5E9
....................    { 
....................       senha[i] = 0; 
05E2:  MOVLW  23
05E3:  ADDWF  2B,W
05E4:  MOVWF  04
05E5:  BCF    03.7
05E6:  CLRF   00
....................    } 
05E7:  INCF   2B,F
05E8:  GOTO   5DE
....................  
....................    while (true) 
....................    { 
....................       desenhaTelaInicial(); 
05E9:  GOTO   2B5
....................       delay_ms(300); 
05EA:  MOVLW  02
05EB:  MOVWF  2E
05EC:  MOVLW  96
05ED:  MOVWF  39
05EE:  CALL   0B2
05EF:  DECFSZ 2E,F
05F0:  GOTO   5EC
....................       tmp = tc_tecla(200); 
05F1:  MOVLW  C8
05F2:  MOVWF  2E
05F3:  CALL   2CD
05F4:  MOVF   78,W
05F5:  MOVWF  27
....................  
....................       if (eTeclaValida(tmp)) 
05F6:  MOVF   27,W
05F7:  MOVWF  2E
05F8:  CALL   3F3
05F9:  MOVF   78,F
05FA:  BTFSC  03.2
05FB:  GOTO   711
....................       { 
....................          switch (tmp) 
....................          { 
05FC:  MOVF   27,W
05FD:  XORLW  31
05FE:  BTFSC  03.2
05FF:  GOTO   607
0600:  XORLW  03
0601:  BTFSC  03.2
0602:  GOTO   699
0603:  XORLW  18
0604:  BTFSC  03.2
0605:  GOTO   6DF
0606:  GOTO   709
....................          case '1': 
....................             printf(lcd_escreve, "\fID User: "); 
0607:  MOVLW  5B
0608:  BSF    03.6
0609:  MOVWF  0D
060A:  MOVLW  00
060B:  MOVWF  0F
060C:  BCF    03.6
060D:  CALL   26F
....................             tmp = tc_tecla(200); 
060E:  MOVLW  C8
060F:  MOVWF  2E
0610:  CALL   2CD
0611:  MOVF   78,W
0612:  MOVWF  27
....................             while (!eTeclaValida(tmp)) 
....................             { 
0613:  MOVF   27,W
0614:  MOVWF  2E
0615:  CALL   3F3
0616:  MOVF   78,F
0617:  BTFSS  03.2
0618:  GOTO   626
....................                printf(lcd_escreve, "\fID User: "); 
0619:  MOVLW  61
061A:  BSF    03.6
061B:  MOVWF  0D
061C:  MOVLW  00
061D:  MOVWF  0F
061E:  BCF    03.6
061F:  CALL   26F
....................                tmp = tc_tecla(200); 
0620:  MOVLW  C8
0621:  MOVWF  2E
0622:  CALL   2CD
0623:  MOVF   78,W
0624:  MOVWF  27
....................             } 
0625:  GOTO   613
....................             for (j = 0; j < 1024; j = j + 5) 
0626:  CLRF   2D
0627:  CLRF   2C
0628:  MOVF   2D,W
0629:  SUBLW  03
062A:  BTFSS  03.0
062B:  GOTO   649
....................             { 
....................                if (tmp == read_ext_eeprom((int16)j)) 
062C:  MOVF   2D,W
062D:  MOVWF  39
062E:  MOVF   2C,W
062F:  MOVWF  38
0630:  CALL   413
0631:  MOVF   78,W
0632:  SUBWF  27,W
0633:  BTFSS  03.2
0634:  GOTO   644
....................                { 
....................                   printf(lcd_escreve, "\fUSER JA EXISTE"); 
0635:  MOVLW  67
0636:  BSF    03.6
0637:  MOVWF  0D
0638:  MOVLW  00
0639:  MOVWF  0F
063A:  BCF    03.6
063B:  CALL   26F
....................                   delay_ms(1000); 
063C:  MOVLW  04
063D:  MOVWF  2E
063E:  MOVLW  FA
063F:  MOVWF  39
0640:  CALL   0B2
0641:  DECFSZ 2E,F
0642:  GOTO   63E
....................                   // main(); 
....................                   break; 
0643:  GOTO   649
....................                } 
....................             } 
0644:  MOVLW  05
0645:  ADDWF  2C,F
0646:  BTFSC  03.0
0647:  INCF   2D,F
0648:  GOTO   628
....................             printf(lcd_escreve, "%c", tmp); 
0649:  MOVF   27,W
064A:  MOVWF  38
064B:  CALL   237
....................             write_ext_eeprom(posMemoria, tmp); 
064C:  MOVF   2A,W
064D:  MOVWF  2F
064E:  MOVF   29,W
064F:  MOVWF  2E
0650:  MOVF   27,W
0651:  MOVWF  30
0652:  CALL   1E5
....................             posMemoria++; 
0653:  INCF   29,F
0654:  BTFSC  03.2
0655:  INCF   2A,F
....................             printf(lcd_escreve, "\nSenha: "); 
0656:  MOVLW  6F
0657:  BSF    03.6
0658:  MOVWF  0D
0659:  MOVLW  00
065A:  MOVWF  0F
065B:  BCF    03.6
065C:  CALL   26F
....................             tmp = tc_tecla(200); 
065D:  MOVLW  C8
065E:  MOVWF  2E
065F:  CALL   2CD
0660:  MOVF   78,W
0661:  MOVWF  27
....................             for (i = 0; i < 4; i++) 
0662:  CLRF   2B
0663:  MOVF   2B,W
0664:  SUBLW  03
0665:  BTFSS  03.0
0666:  GOTO   68A
....................             { 
....................                tmp = 'j'; 
0667:  MOVLW  6A
0668:  MOVWF  27
....................                while (!eTeclaValida(tmp)) 
....................                { 
0669:  MOVF   27,W
066A:  MOVWF  2E
066B:  CALL   3F3
066C:  MOVF   78,F
066D:  BTFSS  03.2
066E:  GOTO   675
....................                   tmp = tc_tecla(200); 
066F:  MOVLW  C8
0670:  MOVWF  2E
0671:  CALL   2CD
0672:  MOVF   78,W
0673:  MOVWF  27
....................                } 
0674:  GOTO   669
....................                senha[i] = tmp; 
0675:  MOVLW  23
0676:  ADDWF  2B,W
0677:  MOVWF  04
0678:  BCF    03.7
0679:  MOVF   27,W
067A:  MOVWF  00
....................                printf(lcd_escreve, "%c", tmp); 
067B:  MOVF   27,W
067C:  MOVWF  38
067D:  CALL   237
....................                write_ext_eeprom(posMemoria, tmp); 
067E:  MOVF   2A,W
067F:  MOVWF  2F
0680:  MOVF   29,W
0681:  MOVWF  2E
0682:  MOVF   27,W
0683:  MOVWF  30
0684:  CALL   1E5
....................                posMemoria++; 
0685:  INCF   29,F
0686:  BTFSC  03.2
0687:  INCF   2A,F
....................             } 
0688:  INCF   2B,F
0689:  GOTO   663
....................             printf(lcd_escreve, "\fSenha cadastrada\ncom sucesso!"); 
068A:  MOVLW  74
068B:  BSF    03.6
068C:  MOVWF  0D
068D:  MOVLW  00
068E:  MOVWF  0F
068F:  BCF    03.6
0690:  CALL   26F
....................             delay_ms(1000); 
0691:  MOVLW  04
0692:  MOVWF  2E
0693:  MOVLW  FA
0694:  MOVWF  39
0695:  CALL   0B2
0696:  DECFSZ 2E,F
0697:  GOTO   693
....................             // main(); 
....................             break; 
0698:  GOTO   711
....................          case '2': 
....................             printf(lcd_escreve, "\fID User: "); 
0699:  MOVLW  84
069A:  BSF    03.6
069B:  MOVWF  0D
069C:  MOVLW  00
069D:  MOVWF  0F
069E:  BCF    03.6
069F:  CALL   26F
....................             tmp = tc_tecla(200); 
06A0:  MOVLW  C8
06A1:  MOVWF  2E
06A2:  CALL   2CD
06A3:  MOVF   78,W
06A4:  MOVWF  27
....................             while (!eTeclaValida(tmp)) 
....................             { 
06A5:  MOVF   27,W
06A6:  MOVWF  2E
06A7:  CALL   3F3
06A8:  MOVF   78,F
06A9:  BTFSS  03.2
06AA:  GOTO   6B1
....................                tmp = tc_tecla(200); 
06AB:  MOVLW  C8
06AC:  MOVWF  2E
06AD:  CALL   2CD
06AE:  MOVF   78,W
06AF:  MOVWF  27
....................             } 
06B0:  GOTO   6A5
....................             user = tmp; 
06B1:  MOVF   27,W
06B2:  MOVWF  28
....................             printf(lcd_escreve, "\fStatus: FECHADA\nSenha: "); 
06B3:  MOVLW  8A
06B4:  BSF    03.6
06B5:  MOVWF  0D
06B6:  MOVLW  00
06B7:  MOVWF  0F
06B8:  BCF    03.6
06B9:  CALL   26F
....................             for (i = 0; i < 4; i++) 
06BA:  CLRF   2B
06BB:  MOVF   2B,W
06BC:  SUBLW  03
06BD:  BTFSS  03.0
06BE:  GOTO   6D8
....................             { 
....................                tmp = 'j'; 
06BF:  MOVLW  6A
06C0:  MOVWF  27
....................                while (!eTeclaValida(tmp)) 
....................                { 
06C1:  MOVF   27,W
06C2:  MOVWF  2E
06C3:  CALL   3F3
06C4:  MOVF   78,F
06C5:  BTFSS  03.2
06C6:  GOTO   6CD
....................                   tmp = tc_tecla(200); 
06C7:  MOVLW  C8
06C8:  MOVWF  2E
06C9:  CALL   2CD
06CA:  MOVF   78,W
06CB:  MOVWF  27
....................                } 
06CC:  GOTO   6C1
....................                printf(lcd_escreve, "%c", tmp); 
06CD:  MOVF   27,W
06CE:  MOVWF  38
06CF:  CALL   237
....................                senha[i] = tmp; 
06D0:  MOVLW  23
06D1:  ADDWF  2B,W
06D2:  MOVWF  04
06D3:  BCF    03.7
06D4:  MOVF   27,W
06D5:  MOVWF  00
....................             } 
06D6:  INCF   2B,F
06D7:  GOTO   6BB
....................             confereSenha(user, senha); 
06D8:  MOVF   28,W
06D9:  MOVWF  2E
06DA:  CLRF   30
06DB:  MOVLW  23
06DC:  MOVWF  2F
06DD:  GOTO   4DE
....................             break; 
06DE:  GOTO   711
....................          case '*': 
....................             printf(lcd_escreve, "\fLIMPANDO MEMORIA"); 
06DF:  MOVLW  97
06E0:  BSF    03.6
06E1:  MOVWF  0D
06E2:  MOVLW  00
06E3:  MOVWF  0F
06E4:  BCF    03.6
06E5:  CALL   26F
....................             delay_ms(200); 
06E6:  MOVLW  C8
06E7:  MOVWF  39
06E8:  CALL   0B2
....................             for (j = 0; j < 1024; j++) 
06E9:  CLRF   2D
06EA:  CLRF   2C
06EB:  MOVF   2D,W
06EC:  SUBLW  03
06ED:  BTFSS  03.0
06EE:  GOTO   6FA
....................             { 
....................                write_ext_eeprom(j, 'F'); 
06EF:  MOVF   2D,W
06F0:  MOVWF  2F
06F1:  MOVF   2C,W
06F2:  MOVWF  2E
06F3:  MOVLW  46
06F4:  MOVWF  30
06F5:  CALL   1E5
....................             } 
06F6:  INCF   2C,F
06F7:  BTFSC  03.2
06F8:  INCF   2D,F
06F9:  GOTO   6EB
....................             printf(lcd_escreve, "\fMEMORIA LIMPA"); 
06FA:  MOVLW  A0
06FB:  BSF    03.6
06FC:  MOVWF  0D
06FD:  MOVLW  00
06FE:  MOVWF  0F
06FF:  BCF    03.6
0700:  CALL   26F
....................             delay_ms(1000); 
0701:  MOVLW  04
0702:  MOVWF  2E
0703:  MOVLW  FA
0704:  MOVWF  39
0705:  CALL   0B2
0706:  DECFSZ 2E,F
0707:  GOTO   703
....................             break; 
0708:  GOTO   711
....................          default: 
....................             printf(lcd_escreve, "\fERRO DESCONHECIDO"); 
0709:  MOVLW  A8
070A:  BSF    03.6
070B:  MOVWF  0D
070C:  MOVLW  00
070D:  MOVWF  0F
070E:  BCF    03.6
070F:  CALL   26F
....................             break; 
0710:  GOTO   711
....................          } 
....................       } 
....................    } 
0711:  GOTO   5E9
.................... } 
0712:  SLEEP

Configuration Fuses:
   Word  1: 3F79   XT NOWDT NOPUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
