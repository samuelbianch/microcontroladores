CCS PCM C Compiler, Version 4.104, 5967               19-out-23 18:00

               Filename: D:\Microcontroladores\Trabalho_Fechadura\main.lst

               ROM used: 1832 words (22%)
                         Largest free fragment is 2048
               RAM used: 18 (5%) at main() level
                         40 (11%) worst case
               Stack:    5 locations

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   599
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
05A4:  BCF    03.5
05A5:  CLRF   20
05A6:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... #ifndef STDBOOL_H 
.................... #define STDBOOL_h 
....................  
.................... #define bool _Bool 
.................... #ifndef true 
.................... #define true 1 
.................... #endif 
....................  
.................... #ifndef false 
.................... #define false 0 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // #device adc=8 
....................  
.................... #FUSES NOWDT     // No Watch Dog Timer 
.................... #FUSES XT        // High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT     // No Power Up Timer 
.................... #FUSES NOPROTECT // Code not protected from reading 
.................... #FUSES NODEBUG   // No Debug mode for ICD 
.................... #FUSES BROWNOUT  // Reset when brownout detected 
.................... #FUSES NOLVP     // No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD     // No EE protection 
.................... #FUSES NOWRT     // Program memory not write protected 
.................... #FUSES RESERVED  // Used to set the reserved FUSE bits 
....................  
.................... #use delay(clock = 4000000) 
*
00B2:  MOVLW  3B
00B3:  MOVWF  04
00B4:  BCF    03.7
00B5:  MOVF   00,W
00B6:  BTFSC  03.2
00B7:  GOTO   0C6
00B8:  MOVLW  01
00B9:  MOVWF  78
00BA:  CLRF   77
00BB:  DECFSZ 77,F
00BC:  GOTO   0BB
00BD:  DECFSZ 78,F
00BE:  GOTO   0BA
00BF:  MOVLW  4A
00C0:  MOVWF  77
00C1:  DECFSZ 77,F
00C2:  GOTO   0C1
00C3:  GOTO   0C4
00C4:  DECFSZ 00,F
00C5:  GOTO   0B8
00C6:  RETURN
....................  
.................... #ifndef lcd_enable 
.................... #define lcd_enable pin_A3 // pino enable do LCD 
.................... #define lcd_rs pin_A5     // pino rs do LCD 
.................... #define lcd_rw pin_A4     // pino rw do LCD 
.................... #define lcd_d4 pin_d4     // pino de dados d4 do LCD 
.................... #define lcd_d5 pin_d5     // pino de dados d5 do LCD 
.................... #define lcd_d6 pin_d6     // pino de dados d6 do LCD 
.................... #define lcd_d7 pin_d7     // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulação de módulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fábio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variável de leitura 
.................... 	// lê os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dá um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lê os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
00C7:  BTFSC  42.0
00C8:  GOTO   0CB
00C9:  BCF    08.4
00CA:  GOTO   0CC
00CB:  BSF    08.4
00CC:  BSF    03.5
00CD:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
00CE:  BCF    03.5
00CF:  BTFSC  42.1
00D0:  GOTO   0D3
00D1:  BCF    08.5
00D2:  GOTO   0D4
00D3:  BSF    08.5
00D4:  BSF    03.5
00D5:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
00D6:  BCF    03.5
00D7:  BTFSC  42.2
00D8:  GOTO   0DB
00D9:  BCF    08.6
00DA:  GOTO   0DC
00DB:  BSF    08.6
00DC:  BSF    03.5
00DD:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
00DE:  BCF    03.5
00DF:  BTFSC  42.3
00E0:  GOTO   0E3
00E1:  BCF    08.7
00E2:  GOTO   0E4
00E3:  BSF    08.7
00E4:  BSF    03.5
00E5:  BCF    08.7
.................... 	// dá um pulso na linha enable 
.................... 	output_high(lcd_enable); 
00E6:  BCF    05.3
00E7:  BCF    03.5
00E8:  BSF    05.3
.................... 	output_low(lcd_enable); 
00E9:  BSF    03.5
00EA:  BCF    05.3
00EB:  BCF    03.5
00EC:  BCF    05.3
.................... } 
00ED:  RETURN
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
00EE:  BSF    03.5
00EF:  BCF    05.5
00F0:  BCF    03.5
00F1:  BCF    05.5
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
00F2:  MOVF   3F,F
00F3:  BTFSS  03.2
00F4:  GOTO   0F7
00F5:  BCF    05.5
00F6:  GOTO   0F8
00F7:  BSF    05.5
00F8:  BSF    03.5
00F9:  BCF    05.5
.................... 	delay_us(100);	// aguarda 100 us 
00FA:  MOVLW  21
00FB:  MOVWF  77
00FC:  DECFSZ 77,F
00FD:  GOTO   0FC
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
00FE:  BCF    05.4
00FF:  BCF    03.5
0100:  BCF    05.4
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
0101:  BSF    03.5
0102:  BCF    05.3
0103:  BCF    03.5
0104:  BCF    05.3
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
0105:  SWAPF  40,W
0106:  MOVWF  41
0107:  MOVLW  0F
0108:  ANDWF  41,F
0109:  MOVF   41,W
010A:  MOVWF  42
010B:  CALL   0C7
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
010C:  MOVF   40,W
010D:  ANDLW  0F
010E:  MOVWF  41
010F:  MOVWF  42
0110:  CALL   0C7
.................... } 
0111:  RETURN
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
0112:  BSF    03.5
0113:  BCF    08.4
0114:  BCF    03.5
0115:  BCF    08.4
.................... 	output_low(lcd_d5); 
0116:  BSF    03.5
0117:  BCF    08.5
0118:  BCF    03.5
0119:  BCF    08.5
.................... 	output_low(lcd_d6); 
011A:  BSF    03.5
011B:  BCF    08.6
011C:  BCF    03.5
011D:  BCF    08.6
.................... 	output_low(lcd_d7); 
011E:  BSF    03.5
011F:  BCF    08.7
0120:  BCF    03.5
0121:  BCF    08.7
.................... 	output_low(lcd_rs); 
0122:  BSF    03.5
0123:  BCF    05.5
0124:  BCF    03.5
0125:  BCF    05.5
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
0126:  BSF    03.5
0127:  BCF    05.4
0128:  BCF    03.5
0129:  BSF    05.4
.................... 	#endif 
.................... 	output_low(lcd_enable); 
012A:  BSF    03.5
012B:  BCF    05.3
012C:  BCF    03.5
012D:  BCF    05.3
.................... 	delay_ms(15); 
012E:  MOVLW  0F
012F:  MOVWF  3B
0130:  CALL   0B2
.................... 	// envia uma seqüência de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o módulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
0131:  MOVLW  01
0132:  MOVWF  2E
0133:  MOVF   2E,W
0134:  SUBLW  03
0135:  BTFSS  03.0
0136:  GOTO   13F
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
0137:  MOVLW  03
0138:  MOVWF  42
0139:  CALL   0C7
.................... 		delay_ms(5); 
013A:  MOVLW  05
013B:  MOVWF  3B
013C:  CALL   0B2
.................... 	} 
013D:  INCF   2E,F
013E:  GOTO   133
.................... 	lcd_envia_nibble(2); 
013F:  MOVLW  02
0140:  MOVWF  42
0141:  CALL   0C7
.................... 	// envia string de inicialização do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
0142:  CLRF   2E
0143:  MOVF   2E,W
0144:  SUBLW  03
0145:  BTFSS  03.0
0146:  GOTO   150
0147:  MOVF   2E,W
0148:  CALL   004
0149:  MOVWF  2F
014A:  CLRF   3F
014B:  MOVF   2F,W
014C:  MOVWF  40
014D:  CALL   0EE
014E:  INCF   2E,F
014F:  GOTO   143
.................... } 
0150:  BCF    0A.3
0151:  BCF    0A.4
0152:  GOTO   5EC (RETURN)
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0251:  DECFSZ 3C,W
0252:  GOTO   254
0253:  GOTO   257
....................    	endereco = lcd_seg_lin; 
0254:  MOVLW  40
0255:  MOVWF  3D
....................    else 
0256:  GOTO   258
....................    	endereco = 0; 
0257:  CLRF   3D
....................    endereco += x-1; 
0258:  MOVLW  01
0259:  SUBWF  3B,W
025A:  ADDWF  3D,F
....................    lcd_envia_byte(0,0x80|endereco); 
025B:  MOVF   3D,W
025C:  IORLW  80
025D:  MOVWF  3E
025E:  CLRF   3F
025F:  MOVF   3E,W
0260:  MOVWF  40
0261:  CALL   0EE
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
.................... 	{ 
*
0237:  MOVF   3A,W
0238:  XORLW  0C
0239:  BTFSC  03.2
023A:  GOTO   245
023B:  XORLW  06
023C:  BTFSC  03.2
023D:  GOTO   24D
023E:  XORLW  07
023F:  BTFSC  03.2
0240:  GOTO   24D
0241:  XORLW  05
0242:  BTFSC  03.2
0243:  GOTO   263
0244:  GOTO   268
....................      case '\f' 	:	lcd_envia_byte(0,1); 
0245:  CLRF   3F
0246:  MOVLW  01
0247:  MOVWF  40
0248:  CALL   0EE
.................... 	  			delay_ms(2); 
0249:  MOVLW  02
024A:  MOVWF  3B
024B:  CALL   0B2
.................... 				break; 
024C:  GOTO   26E
....................      case '\n'	: 
.................... 	 case '\r' 	:	lcd_pos_xy(1,2); 
024D:  MOVLW  01
024E:  MOVWF  3B
024F:  MOVLW  02
0250:  MOVWF  3C
.................... 	  			break; 
*
0262:  GOTO   26E
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
0263:  CLRF   3F
0264:  MOVLW  10
0265:  MOVWF  40
0266:  CALL   0EE
.................... 	  			break; 
0267:  GOTO   26E
....................      default	:	lcd_envia_byte(1,c); 
0268:  MOVLW  01
0269:  MOVWF  3F
026A:  MOVF   3A,W
026B:  MOVWF  40
026C:  CALL   0EE
.................... 	  			break; 
026D:  GOTO   26E
....................    } 
.................... } 
026E:  RETURN
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posição do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lê o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
.................... #include "kbd_ext_board2.c" 
.................... /*######################################################################  
....................  Rotina utilizaÃ§Ã£oo do teclado da placa PicSim board4 
....................  Adaptada para o compilador CCS 
....................  Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................  For e-mail suggestions : awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
.................... { 
*
02CD:  CLRF   2F
02CE:  CLRF   30
....................  unsigned int to=0; 
....................  unsigned char k = 0;  
....................  while(((to < timeout)||(!timeout))&&(!k)){ 
02CF:  MOVF   2E,W
02D0:  SUBWF  2F,W
02D1:  BTFSS  03.0
02D2:  GOTO   2D6
02D3:  MOVF   2E,F
02D4:  BTFSS  03.2
02D5:  GOTO   3EB
02D6:  MOVF   30,F
02D7:  BTFSS  03.2
02D8:  GOTO   3EB
....................   
....................   
....................  //------------------------------------------------------------------------- 
....................  //inicio do programa de varredura do teclado matricial 
....................  //-------------------------------------------------------------------------- 
....................  //habilita primeira coluna do teclado 
....................  output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
02D9:  BSF    03.5
02DA:  BCF    06.0
02DB:  BCF    03.5
02DC:  BCF    06.0
02DD:  BSF    03.5
02DE:  BCF    06.1
02DF:  BCF    03.5
02E0:  BSF    06.1
02E1:  BSF    03.5
02E2:  BCF    06.2
02E3:  BCF    03.5
02E4:  BSF    06.2
02E5:  BSF    03.5
02E6:  BCF    06.3
02E7:  BCF    03.5
02E8:  BSF    06.3
....................  delay_ms(20); 
02E9:  MOVLW  14
02EA:  MOVWF  3B
02EB:  CALL   0B2
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
02EC:  BSF    03.5
02ED:  BSF    08.0
02EE:  BCF    03.5
02EF:  BTFSC  08.0
02F0:  GOTO   2F8
02F1:  BSF    03.5
02F2:  BSF    08.0
02F3:  BCF    03.5
02F4:  BTFSS  08.0
02F5:  GOTO   2F1
02F6:  MOVLW  31
02F7:  MOVWF  30
....................  if (input(PIN_D1) == 0){ 
02F8:  BSF    03.5
02F9:  BSF    08.1
02FA:  BCF    03.5
02FB:  BTFSC  08.1
02FC:  GOTO   304
....................  while(input(PIN_D1) == 0); 
02FD:  BSF    03.5
02FE:  BSF    08.1
02FF:  BCF    03.5
0300:  BTFSS  08.1
0301:  GOTO   2FD
....................  k='4'; 
0302:  MOVLW  34
0303:  MOVWF  30
....................  }; 
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
0304:  BSF    03.5
0305:  BSF    08.2
0306:  BCF    03.5
0307:  BTFSC  08.2
0308:  GOTO   310
0309:  BSF    03.5
030A:  BSF    08.2
030B:  BCF    03.5
030C:  BTFSS  08.2
030D:  GOTO   309
030E:  MOVLW  37
030F:  MOVWF  30
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
0310:  BSF    03.5
0311:  BSF    08.3
0312:  BCF    03.5
0313:  BTFSC  08.3
0314:  GOTO   31C
0315:  BSF    03.5
0316:  BSF    08.3
0317:  BCF    03.5
0318:  BTFSS  08.3
0319:  GOTO   315
031A:  MOVLW  2A
031B:  MOVWF  30
....................  //habilita segunda coluna do teclado 
....................  output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
031C:  BSF    03.5
031D:  BCF    06.0
031E:  BCF    03.5
031F:  BSF    06.0
0320:  BSF    03.5
0321:  BCF    06.1
0322:  BCF    03.5
0323:  BCF    06.1
0324:  BSF    03.5
0325:  BCF    06.2
0326:  BCF    03.5
0327:  BSF    06.2
0328:  BSF    03.5
0329:  BCF    06.3
032A:  BCF    03.5
032B:  BSF    06.3
....................  delay_ms(20);  
032C:  MOVLW  14
032D:  MOVWF  3B
032E:  CALL   0B2
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
032F:  BSF    03.5
0330:  BSF    08.0
0331:  BCF    03.5
0332:  BTFSC  08.0
0333:  GOTO   33B
0334:  BSF    03.5
0335:  BSF    08.0
0336:  BCF    03.5
0337:  BTFSS  08.0
0338:  GOTO   334
0339:  MOVLW  32
033A:  MOVWF  30
....................  if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
033B:  BSF    03.5
033C:  BSF    08.1
033D:  BCF    03.5
033E:  BTFSC  08.1
033F:  GOTO   347
0340:  BSF    03.5
0341:  BSF    08.1
0342:  BCF    03.5
0343:  BTFSS  08.1
0344:  GOTO   340
0345:  MOVLW  35
0346:  MOVWF  30
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
0347:  BSF    03.5
0348:  BSF    08.2
0349:  BCF    03.5
034A:  BTFSC  08.2
034B:  GOTO   353
034C:  BSF    03.5
034D:  BSF    08.2
034E:  BCF    03.5
034F:  BTFSS  08.2
0350:  GOTO   34C
0351:  MOVLW  38
0352:  MOVWF  30
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
0353:  BSF    03.5
0354:  BSF    08.3
0355:  BCF    03.5
0356:  BTFSC  08.3
0357:  GOTO   35F
0358:  BSF    03.5
0359:  BSF    08.3
035A:  BCF    03.5
035B:  BTFSS  08.3
035C:  GOTO   358
035D:  MOVLW  30
035E:  MOVWF  30
....................   
....................  //habilita terceira coluna do teclado 
....................  output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
035F:  BSF    03.5
0360:  BCF    06.0
0361:  BCF    03.5
0362:  BSF    06.0
0363:  BSF    03.5
0364:  BCF    06.1
0365:  BCF    03.5
0366:  BSF    06.1
0367:  BSF    03.5
0368:  BCF    06.2
0369:  BCF    03.5
036A:  BCF    06.2
036B:  BSF    03.5
036C:  BCF    06.3
036D:  BCF    03.5
036E:  BSF    06.3
....................  delay_ms(20);  
036F:  MOVLW  14
0370:  MOVWF  3B
0371:  CALL   0B2
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
0372:  BSF    03.5
0373:  BSF    08.0
0374:  BCF    03.5
0375:  BTFSC  08.0
0376:  GOTO   37E
0377:  BSF    03.5
0378:  BSF    08.0
0379:  BCF    03.5
037A:  BTFSS  08.0
037B:  GOTO   377
037C:  MOVLW  33
037D:  MOVWF  30
....................  if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
037E:  BSF    03.5
037F:  BSF    08.1
0380:  BCF    03.5
0381:  BTFSC  08.1
0382:  GOTO   38A
0383:  BSF    03.5
0384:  BSF    08.1
0385:  BCF    03.5
0386:  BTFSS  08.1
0387:  GOTO   383
0388:  MOVLW  36
0389:  MOVWF  30
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
038A:  BSF    03.5
038B:  BSF    08.2
038C:  BCF    03.5
038D:  BTFSC  08.2
038E:  GOTO   396
038F:  BSF    03.5
0390:  BSF    08.2
0391:  BCF    03.5
0392:  BTFSS  08.2
0393:  GOTO   38F
0394:  MOVLW  39
0395:  MOVWF  30
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
0396:  BSF    03.5
0397:  BSF    08.3
0398:  BCF    03.5
0399:  BTFSC  08.3
039A:  GOTO   3A2
039B:  BSF    03.5
039C:  BSF    08.3
039D:  BCF    03.5
039E:  BTFSS  08.3
039F:  GOTO   39B
03A0:  MOVLW  23
03A1:  MOVWF  30
....................  //habilita quarta coluna do teclado 
....................  output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
03A2:  BSF    03.5
03A3:  BCF    06.0
03A4:  BCF    03.5
03A5:  BSF    06.0
03A6:  BSF    03.5
03A7:  BCF    06.1
03A8:  BCF    03.5
03A9:  BSF    06.1
03AA:  BSF    03.5
03AB:  BCF    06.2
03AC:  BCF    03.5
03AD:  BSF    06.2
03AE:  BSF    03.5
03AF:  BCF    06.3
03B0:  BCF    03.5
03B1:  BCF    06.3
....................  delay_ms(20);  
03B2:  MOVLW  14
03B3:  MOVWF  3B
03B4:  CALL   0B2
....................  if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
03B5:  BSF    03.5
03B6:  BSF    08.0
03B7:  BCF    03.5
03B8:  BTFSC  08.0
03B9:  GOTO   3C1
03BA:  BSF    03.5
03BB:  BSF    08.0
03BC:  BCF    03.5
03BD:  BTFSS  08.0
03BE:  GOTO   3BA
03BF:  MOVLW  41
03C0:  MOVWF  30
....................  if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
03C1:  BSF    03.5
03C2:  BSF    08.1
03C3:  BCF    03.5
03C4:  BTFSC  08.1
03C5:  GOTO   3CD
03C6:  BSF    03.5
03C7:  BSF    08.1
03C8:  BCF    03.5
03C9:  BTFSS  08.1
03CA:  GOTO   3C6
03CB:  MOVLW  42
03CC:  MOVWF  30
....................  if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
03CD:  BSF    03.5
03CE:  BSF    08.2
03CF:  BCF    03.5
03D0:  BTFSC  08.2
03D1:  GOTO   3D9
03D2:  BSF    03.5
03D3:  BSF    08.2
03D4:  BCF    03.5
03D5:  BTFSS  08.2
03D6:  GOTO   3D2
03D7:  MOVLW  43
03D8:  MOVWF  30
....................  if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
03D9:  BSF    03.5
03DA:  BSF    08.3
03DB:  BCF    03.5
03DC:  BTFSC  08.3
03DD:  GOTO   3E5
03DE:  BSF    03.5
03DF:  BSF    08.3
03E0:  BCF    03.5
03E1:  BTFSS  08.3
03E2:  GOTO   3DE
03E3:  MOVLW  44
03E4:  MOVWF  30
....................   
....................  delay_ms(5); 
03E5:  MOVLW  05
03E6:  MOVWF  3B
03E7:  CALL   0B2
....................  to+=5; 
03E8:  MOVLW  05
03E9:  ADDWF  2F,F
....................  } 
03EA:  GOTO   2CF
....................  if(!k)k=255; 
03EB:  MOVF   30,F
03EC:  BTFSS  03.2
03ED:  GOTO   3F0
03EE:  MOVLW  FF
03EF:  MOVWF  30
....................  return k;  
03F0:  MOVF   30,W
03F1:  MOVWF  78
.................... } 
03F2:  RETURN
....................  
.................... #include "2408.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC08B                                 //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0160:  MOVLW  08
0161:  MOVWF  78
0162:  NOP
0163:  BCF    07.3
0164:  BCF    22.3
0165:  MOVF   22,W
0166:  BSF    03.5
0167:  MOVWF  07
0168:  NOP
0169:  BCF    03.5
016A:  RLF    3E,F
016B:  BCF    07.4
016C:  BTFSS  03.0
016D:  GOTO   174
016E:  BSF    22.4
016F:  MOVF   22,W
0170:  BSF    03.5
0171:  MOVWF  07
0172:  GOTO   178
0173:  BCF    03.5
0174:  BCF    22.4
0175:  MOVF   22,W
0176:  BSF    03.5
0177:  MOVWF  07
0178:  NOP
0179:  BCF    03.5
017A:  BSF    22.3
017B:  MOVF   22,W
017C:  BSF    03.5
017D:  MOVWF  07
017E:  BCF    03.5
017F:  BTFSS  07.3
0180:  GOTO   17F
0181:  DECFSZ 78,F
0182:  GOTO   162
0183:  NOP
0184:  BCF    07.3
0185:  BCF    22.3
0186:  MOVF   22,W
0187:  BSF    03.5
0188:  MOVWF  07
0189:  NOP
018A:  BCF    03.5
018B:  BSF    22.4
018C:  MOVF   22,W
018D:  BSF    03.5
018E:  MOVWF  07
018F:  NOP
0190:  NOP
0191:  BCF    03.5
0192:  BSF    22.3
0193:  MOVF   22,W
0194:  BSF    03.5
0195:  MOVWF  07
0196:  BCF    03.5
0197:  BTFSS  07.3
0198:  GOTO   197
0199:  CLRF   78
019A:  NOP
019B:  BTFSC  07.4
019C:  BSF    78.0
019D:  BCF    07.3
019E:  BCF    22.3
019F:  MOVF   22,W
01A0:  BSF    03.5
01A1:  MOVWF  07
01A2:  BCF    03.5
01A3:  BCF    07.4
01A4:  BCF    22.4
01A5:  MOVF   22,W
01A6:  BSF    03.5
01A7:  MOVWF  07
01A8:  BCF    03.5
01A9:  RETURN
*
047F:  MOVLW  08
0480:  MOVWF  3E
0481:  MOVF   77,W
0482:  MOVWF  3F
0483:  BSF    22.4
0484:  MOVF   22,W
0485:  BSF    03.5
0486:  MOVWF  07
0487:  NOP
0488:  BCF    03.5
0489:  BSF    22.3
048A:  MOVF   22,W
048B:  BSF    03.5
048C:  MOVWF  07
048D:  BCF    03.5
048E:  BTFSS  07.3
048F:  GOTO   48E
0490:  BTFSC  07.4
0491:  BSF    03.0
0492:  BTFSS  07.4
0493:  BCF    03.0
0494:  RLF    78,F
0495:  NOP
0496:  BCF    22.3
0497:  MOVF   22,W
0498:  BSF    03.5
0499:  MOVWF  07
049A:  BCF    03.5
049B:  BCF    07.3
049C:  DECFSZ 3E,F
049D:  GOTO   483
049E:  BSF    22.4
049F:  MOVF   22,W
04A0:  BSF    03.5
04A1:  MOVWF  07
04A2:  NOP
04A3:  BCF    03.5
04A4:  BCF    07.4
04A5:  MOVF   3F,W
04A6:  BTFSC  03.2
04A7:  GOTO   4AD
04A8:  BCF    22.4
04A9:  MOVF   22,W
04AA:  BSF    03.5
04AB:  MOVWF  07
04AC:  BCF    03.5
04AD:  NOP
04AE:  BSF    22.3
04AF:  MOVF   22,W
04B0:  BSF    03.5
04B1:  MOVWF  07
04B2:  BCF    03.5
04B3:  BTFSS  07.3
04B4:  GOTO   4B3
04B5:  NOP
04B6:  BCF    07.3
04B7:  BCF    22.3
04B8:  MOVF   22,W
04B9:  BSF    03.5
04BA:  MOVWF  07
04BB:  NOP
04BC:  BCF    03.5
04BD:  BCF    07.4
04BE:  BCF    22.4
04BF:  MOVF   22,W
04C0:  BSF    03.5
04C1:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE    1024 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0153:  BSF    22.3
0154:  MOVF   22,W
0155:  BSF    03.5
0156:  MOVWF  07
....................    output_float(EEPROM_SDA); 
0157:  BCF    03.5
0158:  BSF    22.4
0159:  MOVF   22,W
015A:  BSF    03.5
015B:  MOVWF  07
.................... } 
015C:  BCF    03.5
015D:  BCF    0A.3
015E:  BCF    0A.4
015F:  GOTO   5F0 (RETURN)
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
01AA:  BSF    22.4
01AB:  MOVF   22,W
01AC:  BSF    03.5
01AD:  MOVWF  07
01AE:  NOP
01AF:  BCF    03.5
01B0:  BSF    22.3
01B1:  MOVF   22,W
01B2:  BSF    03.5
01B3:  MOVWF  07
01B4:  NOP
01B5:  BCF    03.5
01B6:  BCF    07.4
01B7:  BCF    22.4
01B8:  MOVF   22,W
01B9:  BSF    03.5
01BA:  MOVWF  07
01BB:  NOP
01BC:  BCF    03.5
01BD:  BCF    07.3
01BE:  BCF    22.3
01BF:  MOVF   22,W
01C0:  BSF    03.5
01C1:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
01C2:  MOVLW  A0
01C3:  BCF    03.5
01C4:  MOVWF  3E
01C5:  CALL   160
01C6:  MOVF   78,W
01C7:  BCF    3D.0
01C8:  BTFSC  78.0
01C9:  BSF    3D.0
....................    i2c_stop(); 
01CA:  BCF    22.4
01CB:  MOVF   22,W
01CC:  BSF    03.5
01CD:  MOVWF  07
01CE:  NOP
01CF:  BCF    03.5
01D0:  BSF    22.3
01D1:  MOVF   22,W
01D2:  BSF    03.5
01D3:  MOVWF  07
01D4:  BCF    03.5
01D5:  BTFSS  07.3
01D6:  GOTO   1D5
01D7:  NOP
01D8:  GOTO   1D9
01D9:  NOP
01DA:  BSF    22.4
01DB:  MOVF   22,W
01DC:  BSF    03.5
01DD:  MOVWF  07
01DE:  NOP
....................    return !ack; 
01DF:  MOVLW  00
01E0:  BCF    03.5
01E1:  BTFSS  3D.0
01E2:  MOVLW  01
01E3:  MOVWF  78
.................... } 
01E4:  RETURN
....................  
.................... void write_ext_eeprom(long int address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
01E5:  CALL   1AA
01E6:  MOVF   78,F
01E7:  BTFSC  03.2
01E8:  GOTO   1E5
....................    i2c_start(); 
01E9:  BSF    22.4
01EA:  MOVF   22,W
01EB:  BSF    03.5
01EC:  MOVWF  07
01ED:  NOP
01EE:  BCF    03.5
01EF:  BSF    22.3
01F0:  MOVF   22,W
01F1:  BSF    03.5
01F2:  MOVWF  07
01F3:  NOP
01F4:  BCF    03.5
01F5:  BCF    07.4
01F6:  BCF    22.4
01F7:  MOVF   22,W
01F8:  BSF    03.5
01F9:  MOVWF  07
01FA:  NOP
01FB:  BCF    03.5
01FC:  BCF    07.3
01FD:  BCF    22.3
01FE:  MOVF   22,W
01FF:  BSF    03.5
0200:  MOVWF  07
....................    i2c_write((0xa0|(BYTE)(address>>7))&0xfe); 
0201:  BCF    03.5
0202:  RRF    2F,W
0203:  MOVWF  7A
0204:  RRF    2E,W
0205:  MOVWF  79
0206:  RRF    7A,F
0207:  RRF    79,F
0208:  RRF    7A,F
0209:  RRF    79,F
020A:  RRF    7A,F
020B:  RRF    79,F
020C:  RRF    7A,F
020D:  RRF    79,F
020E:  RRF    7A,F
020F:  RRF    79,F
0210:  RRF    7A,F
0211:  RRF    79,F
0212:  MOVLW  01
0213:  ANDWF  7A,F
0214:  MOVF   79,W
0215:  IORLW  A0
0216:  ANDLW  FE
0217:  MOVWF  31
0218:  MOVWF  3E
0219:  CALL   160
....................    i2c_write(address); 
021A:  MOVF   2E,W
021B:  MOVWF  3E
021C:  CALL   160
....................    i2c_write(data); 
021D:  MOVF   30,W
021E:  MOVWF  3E
021F:  CALL   160
....................    i2c_stop(); 
0220:  BCF    22.4
0221:  MOVF   22,W
0222:  BSF    03.5
0223:  MOVWF  07
0224:  NOP
0225:  BCF    03.5
0226:  BSF    22.3
0227:  MOVF   22,W
0228:  BSF    03.5
0229:  MOVWF  07
022A:  BCF    03.5
022B:  BTFSS  07.3
022C:  GOTO   22B
022D:  NOP
022E:  GOTO   22F
022F:  NOP
0230:  BSF    22.4
0231:  MOVF   22,W
0232:  BSF    03.5
0233:  MOVWF  07
0234:  NOP
.................... } 
0235:  BCF    03.5
0236:  RETURN
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
0413:  CALL   1AA
0414:  MOVF   78,F
0415:  BTFSC  03.2
0416:  GOTO   413
....................    i2c_start(); 
0417:  BSF    22.4
0418:  MOVF   22,W
0419:  BSF    03.5
041A:  MOVWF  07
041B:  NOP
041C:  BCF    03.5
041D:  BSF    22.3
041E:  MOVF   22,W
041F:  BSF    03.5
0420:  MOVWF  07
0421:  NOP
0422:  BCF    03.5
0423:  BCF    07.4
0424:  BCF    22.4
0425:  MOVF   22,W
0426:  BSF    03.5
0427:  MOVWF  07
0428:  NOP
0429:  BCF    03.5
042A:  BCF    07.3
042B:  BCF    22.3
042C:  MOVF   22,W
042D:  BSF    03.5
042E:  MOVWF  07
....................    i2c_write((0xa0|(BYTE)(address>>7))&0xfe); 
042F:  BCF    03.5
0430:  RRF    3B,W
0431:  MOVWF  7A
0432:  RRF    3A,W
0433:  MOVWF  79
0434:  RRF    7A,F
0435:  RRF    79,F
0436:  RRF    7A,F
0437:  RRF    79,F
0438:  RRF    7A,F
0439:  RRF    79,F
043A:  RRF    7A,F
043B:  RRF    79,F
043C:  RRF    7A,F
043D:  RRF    79,F
043E:  RRF    7A,F
043F:  RRF    79,F
0440:  MOVLW  01
0441:  ANDWF  7A,F
0442:  MOVF   79,W
0443:  IORLW  A0
0444:  ANDLW  FE
0445:  MOVWF  3D
0446:  MOVWF  3E
0447:  CALL   160
....................    i2c_write(address); 
0448:  MOVF   3A,W
0449:  MOVWF  3E
044A:  CALL   160
....................    i2c_start(); 
044B:  BSF    22.4
044C:  MOVF   22,W
044D:  BSF    03.5
044E:  MOVWF  07
044F:  NOP
0450:  BCF    03.5
0451:  BSF    22.3
0452:  MOVF   22,W
0453:  BSF    03.5
0454:  MOVWF  07
0455:  NOP
0456:  BCF    03.5
0457:  BTFSS  07.3
0458:  GOTO   457
0459:  BCF    07.4
045A:  BCF    22.4
045B:  MOVF   22,W
045C:  BSF    03.5
045D:  MOVWF  07
045E:  NOP
045F:  BCF    03.5
0460:  BCF    07.3
0461:  BCF    22.3
0462:  MOVF   22,W
0463:  BSF    03.5
0464:  MOVWF  07
....................    i2c_write((0xa0|(BYTE)(address>>7))|1); 
0465:  BCF    03.5
0466:  RRF    3B,W
0467:  MOVWF  7A
0468:  RRF    3A,W
0469:  MOVWF  79
046A:  RRF    7A,F
046B:  RRF    79,F
046C:  RRF    7A,F
046D:  RRF    79,F
046E:  RRF    7A,F
046F:  RRF    79,F
0470:  RRF    7A,F
0471:  RRF    79,F
0472:  RRF    7A,F
0473:  RRF    79,F
0474:  RRF    7A,F
0475:  RRF    79,F
0476:  MOVLW  01
0477:  ANDWF  7A,F
0478:  MOVF   79,W
0479:  IORLW  A0
047A:  IORLW  01
047B:  MOVWF  3D
047C:  MOVWF  3E
047D:  CALL   160
....................    data=i2c_read(0); 
047E:  CLRF   77
*
04C2:  MOVF   78,W
04C3:  BCF    03.5
04C4:  MOVWF  3C
....................    i2c_stop(); 
04C5:  BCF    22.4
04C6:  MOVF   22,W
04C7:  BSF    03.5
04C8:  MOVWF  07
04C9:  NOP
04CA:  BCF    03.5
04CB:  BSF    22.3
04CC:  MOVF   22,W
04CD:  BSF    03.5
04CE:  MOVWF  07
04CF:  BCF    03.5
04D0:  BTFSS  07.3
04D1:  GOTO   4D0
04D2:  NOP
04D3:  GOTO   4D4
04D4:  NOP
04D5:  BSF    22.4
04D6:  MOVF   22,W
04D7:  BSF    03.5
04D8:  MOVWF  07
04D9:  NOP
....................    return(data); 
04DA:  BCF    03.5
04DB:  MOVF   3C,W
04DC:  MOVWF  78
.................... } 
04DD:  RETURN
....................  
....................  
.................... long int End_HL(byte H, byte L) 
.................... { 
....................    return (H << 8) + L; 
.................... } 
....................  
.................... char *IntToHex(int value) 
.................... { 
....................    int a; 
....................    int b; 
....................    char *buffer; 
....................  
....................    a = value && 16; 
....................    b = (value >> 4) & 16; 
....................    buffer[0] = (a < 10) ? '0' + a : 'A' - (a - 10); 
....................    buffer[1] = (b < 10) ? '0' + b : 'A' - (b - 10); 
....................  
....................    return buffer; 
.................... } 
....................  
.................... void WRITE_FLOAT_EXT_EEPROM(long int n, float data) 
.................... { 
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
....................       write_ext_eeprom(i + n, *((int8 *)&data + i)); 
.................... } 
....................  
.................... float READ_FLOAT_EXT_EEPROM(long int n) 
.................... { 
....................    int i; 
....................    float data; 
....................  
....................    for (i = 0; i < 4; i++) 
....................       *((int8 *)&data + i) = read_ext_eeprom(i + n); 
....................  
....................    return ((float)data); 
.................... } 
....................  
.................... void eeprom_int16(unsigned int endereco, int16 valor_i16) 
.................... { 
....................    write_ext_eeprom(endereco, make8(valor_i16, 0)); 
....................    write_ext_eeprom(endereco + 1, make8(valor_i16, 1)); 
.................... } 
....................  
.................... int1 eTeclaValida(char c) 
.................... { 
....................    if (((int)c >= 48 && (int)c <= 57) || ((int)c >= 65 && (int)c <= 68) || ((int)c == 42 || (int)c == 35)) 
*
03F3:  MOVF   2E,W
03F4:  SUBLW  2F
03F5:  BTFSC  03.0
03F6:  GOTO   3FB
03F7:  MOVF   2E,W
03F8:  SUBLW  39
03F9:  BTFSC  03.0
03FA:  GOTO   40B
03FB:  MOVF   2E,W
03FC:  SUBLW  40
03FD:  BTFSC  03.0
03FE:  GOTO   403
03FF:  MOVF   2E,W
0400:  SUBLW  44
0401:  BTFSC  03.0
0402:  GOTO   40B
0403:  MOVF   2E,W
0404:  SUBLW  2A
0405:  BTFSC  03.2
0406:  GOTO   40B
0407:  MOVF   2E,W
0408:  SUBLW  23
0409:  BTFSS  03.2
040A:  GOTO   40F
....................       return 1; 
040B:  MOVLW  01
040C:  MOVWF  78
040D:  GOTO   412
....................    else 
040E:  GOTO   412
....................       return 0; 
040F:  MOVLW  00
0410:  MOVWF  78
0411:  GOTO   412
.................... } 
0412:  RETURN
....................  
.................... void desenhaTelaInicial() 
.................... { 
....................    printf(lcd_escreve, "\fSeja bem vindo!"); 
*
02B5:  MOVLW  0C
02B6:  BSF    03.6
02B7:  MOVWF  0D
02B8:  MOVLW  00
02B9:  MOVWF  0F
02BA:  BCF    03.6
02BB:  CALL   26F
....................    delay_ms(1000); 
02BC:  MOVLW  04
02BD:  MOVWF  2E
02BE:  MOVLW  FA
02BF:  MOVWF  3B
02C0:  CALL   0B2
02C1:  DECFSZ 2E,F
02C2:  GOTO   2BE
....................    printf(lcd_escreve, "\f1 - Cadastrar\n2 - Utilizar"); 
02C3:  MOVLW  15
02C4:  BSF    03.6
02C5:  MOVWF  0D
02C6:  MOVLW  00
02C7:  MOVWF  0F
02C8:  BCF    03.6
02C9:  CALL   26F
.................... } 
02CA:  BCF    0A.3
02CB:  BCF    0A.4
02CC:  GOTO   61C (RETURN)
....................  
.................... void desenhaTelaCadastrar(int userID, char senha[]) 
.................... { 
....................    printf(lcd_escreve, "\fID User: %d\nSenha: %s", userID, senha); 
.................... } 
....................  
.................... void confereSenha(char user, char senha[]) 
.................... { 
*
005A:  DATA 00,00
*
0508:  BCF    32.0
0509:  BCF    32.1
050A:  CLRF   33
....................    int8 c; 
....................    int1 senhaEstaCorreta = 0, userExiste = 0; 
....................    int8 digitosIguais = 0; 
....................    int16 j; 
....................  
....................    for (j = 0; j < 1024; j = j + 5) 
050B:  CLRF   35
050C:  CLRF   34
050D:  MOVF   35,W
050E:  SUBLW  03
050F:  BTFSS  03.0
0510:  GOTO   551
....................    { 
....................       if (user == read_ext_eeprom((int16)j)) 
0511:  MOVF   35,W
0512:  MOVWF  3B
0513:  MOVF   34,W
0514:  MOVWF  3A
0515:  CALL   413
0516:  MOVF   78,W
0517:  SUBWF  2E,W
0518:  BTFSS  03.2
0519:  GOTO   54C
....................       { 
....................          userExiste = 1; 
051A:  BSF    32.1
....................          int8 i = 0; 
051B:  CLRF   36
....................          for (c = j + 1; c < j + 5; c++) 
051C:  MOVLW  01
051D:  ADDWF  34,W
051E:  MOVWF  31
051F:  MOVLW  05
0520:  ADDWF  34,W
0521:  MOVWF  78
0522:  MOVF   35,W
0523:  MOVWF  7A
0524:  BTFSC  03.0
0525:  INCF   7A,F
0526:  MOVF   78,W
0527:  MOVF   7A,F
0528:  BTFSS  03.2
0529:  GOTO   52E
052A:  MOVF   78,W
052B:  SUBWF  31,W
052C:  BTFSC  03.0
052D:  GOTO   54C
....................          { 
....................             if (senha[i] == read_ext_eeprom((int16)c)) 
052E:  MOVF   36,W
052F:  ADDWF  2F,W
0530:  MOVWF  04
0531:  BCF    03.7
0532:  BTFSC  30.0
0533:  BSF    03.7
0534:  MOVF   00,W
0535:  MOVWF  37
0536:  CLRF   39
0537:  MOVF   31,W
0538:  MOVWF  38
0539:  MOVF   39,W
053A:  MOVWF  3B
053B:  MOVF   38,W
053C:  MOVWF  3A
053D:  CALL   413
053E:  MOVF   78,W
053F:  SUBWF  37,W
0540:  BTFSS  03.2
0541:  GOTO   543
....................             { 
....................                digitosIguais++; 
0542:  INCF   33,F
....................             } 
....................             if (digitosIguais == 4) 
0543:  MOVF   33,W
0544:  SUBLW  04
0545:  BTFSS  03.2
0546:  GOTO   549
....................             { 
....................                senhaEstaCorreta = 1; 
0547:  BSF    32.0
....................                break; 
0548:  GOTO   54C
....................             } 
....................             i++; 
0549:  INCF   36,F
....................          } 
054A:  INCF   31,F
054B:  GOTO   51F
....................       } 
....................    } 
054C:  MOVLW  05
054D:  ADDWF  34,F
054E:  BTFSC  03.0
054F:  INCF   35,F
0550:  GOTO   50D
....................  
....................    if (senhaEstaCorreta == 1 && userExiste == 1) 
0551:  BTFSS  32.0
0552:  GOTO   564
0553:  BTFSS  32.1
0554:  GOTO   564
....................    { 
....................       printf(lcd_escreve, "\fPARABENS PORTA\nABERTA!!"); 
0555:  MOVLW  2F
0556:  BSF    03.6
0557:  MOVWF  0D
0558:  MOVLW  00
0559:  MOVWF  0F
055A:  BCF    03.6
055B:  CALL   26F
....................       delay_ms(3000); 
055C:  MOVLW  0C
055D:  MOVWF  37
055E:  MOVLW  FA
055F:  MOVWF  3B
0560:  CALL   0B2
0561:  DECFSZ 37,F
0562:  GOTO   55E
....................    } 
....................    else if (userExiste == 0) 
0563:  GOTO   596
0564:  BTFSC  32.1
0565:  GOTO   575
....................    { 
....................       printf(lcd_escreve, "\fUsuario Nao\nExiste!"); 
0566:  MOVLW  3C
0567:  BSF    03.6
0568:  MOVWF  0D
0569:  MOVLW  00
056A:  MOVWF  0F
056B:  BCF    03.6
056C:  CALL   26F
....................       delay_ms(3000); 
056D:  MOVLW  0C
056E:  MOVWF  37
056F:  MOVLW  FA
0570:  MOVWF  3B
0571:  CALL   0B2
0572:  DECFSZ 37,F
0573:  GOTO   56F
....................    } 
....................    else if (userExiste == 1 && senhaEstaCorreta == 0) 
0574:  GOTO   596
0575:  BTFSS  32.1
0576:  GOTO   588
0577:  BTFSC  32.0
0578:  GOTO   588
....................    { 
....................       printf(lcd_escreve, "\fSenha Invalida!"); 
0579:  MOVLW  47
057A:  BSF    03.6
057B:  MOVWF  0D
057C:  MOVLW  00
057D:  MOVWF  0F
057E:  BCF    03.6
057F:  CALL   26F
....................       delay_ms(3000); 
0580:  MOVLW  0C
0581:  MOVWF  37
0582:  MOVLW  FA
0583:  MOVWF  3B
0584:  CALL   0B2
0585:  DECFSZ 37,F
0586:  GOTO   582
....................    } 
....................    else 
0587:  GOTO   596
....................    { 
....................       printf(lcd_escreve, "\fERRO AO\nAUTENTICAR!"); 
0588:  MOVLW  50
0589:  BSF    03.6
058A:  MOVWF  0D
058B:  MOVLW  00
058C:  MOVWF  0F
058D:  BCF    03.6
058E:  CALL   26F
....................       delay_ms(3000); 
058F:  MOVLW  0C
0590:  MOVWF  37
0591:  MOVLW  FA
0592:  MOVWF  3B
0593:  CALL   0B2
0594:  DECFSZ 37,F
0595:  GOTO   591
....................    } 
.................... } 
0596:  BCF    0A.3
0597:  BCF    0A.4
0598:  GOTO   726 (RETURN)
....................  
.................... int1 confereUserJaExiste(char user) 
.................... { 
....................    int16 j; 
....................    for (j = 0; j < 1024; j = j + 5) 
*
04DE:  CLRF   30
04DF:  CLRF   2F
04E0:  MOVF   30,W
04E1:  SUBLW  03
04E2:  BTFSS  03.0
04E3:  GOTO   503
....................    { 
....................       if (user == read_ext_eeprom((int16)j)) 
04E4:  MOVF   30,W
04E5:  MOVWF  3B
04E6:  MOVF   2F,W
04E7:  MOVWF  3A
04E8:  CALL   413
04E9:  MOVF   78,W
04EA:  SUBWF  2E,W
04EB:  BTFSS  03.2
04EC:  GOTO   4FE
....................       { 
....................          printf(lcd_escreve, "\fUSER JA EXISTE"); 
04ED:  MOVLW  5B
04EE:  BSF    03.6
04EF:  MOVWF  0D
04F0:  MOVLW  00
04F1:  MOVWF  0F
04F2:  BCF    03.6
04F3:  CALL   26F
....................          delay_ms(1000); 
04F4:  MOVLW  04
04F5:  MOVWF  31
04F6:  MOVLW  FA
04F7:  MOVWF  3B
04F8:  CALL   0B2
04F9:  DECFSZ 31,F
04FA:  GOTO   4F6
....................          return 0; 
04FB:  MOVLW  00
04FC:  MOVWF  78
04FD:  GOTO   505
....................       } 
....................    } 
04FE:  MOVLW  05
04FF:  ADDWF  2F,F
0500:  BTFSC  03.0
0501:  INCF   30,F
0502:  GOTO   4E0
....................  
....................    return 1; 
0503:  MOVLW  01
0504:  MOVWF  78
.................... } 
0505:  BCF    0A.3
0506:  BCF    0A.4
0507:  GOTO   65B (RETURN)
....................  
.................... void main() 
.................... { 
*
00B1:  DATA 00,00
*
0599:  CLRF   04
059A:  BCF    03.7
059B:  MOVLW  1F
059C:  ANDWF  03,F
059D:  BSF    03.5
059E:  BSF    1F.0
059F:  BSF    1F.1
05A0:  BSF    1F.2
05A1:  BCF    1F.3
05A2:  MOVLW  07
05A3:  MOVWF  1C
*
05AA:  CLRF   2A
05AB:  CLRF   29
....................    char senha[4] = ""; 
*
05A9:  CLRF   23
....................    char tmp, user; 
....................    int16 posMemoria = 0; 
....................  
....................    setup_adc_ports(AN0); 
*
05AC:  BSF    03.5
05AD:  BCF    1F.0
05AE:  BSF    1F.1
05AF:  BSF    1F.2
05B0:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_DIV_2); 
05B1:  BCF    1F.6
05B2:  BCF    03.5
05B3:  BCF    1F.6
05B4:  BCF    1F.7
05B5:  BSF    03.5
05B6:  BCF    1F.7
05B7:  BCF    03.5
05B8:  BSF    1F.0
....................    setup_psp(PSP_DISABLED); 
05B9:  BSF    03.5
05BA:  BCF    09.4
....................    setup_spi(SPI_SS_DISABLED); 
05BB:  BCF    03.5
05BC:  BCF    14.5
05BD:  BCF    22.5
05BE:  MOVF   22,W
05BF:  BSF    03.5
05C0:  MOVWF  07
05C1:  BCF    03.5
05C2:  BSF    22.4
05C3:  MOVF   22,W
05C4:  BSF    03.5
05C5:  MOVWF  07
05C6:  BCF    03.5
05C7:  BCF    22.3
05C8:  MOVF   22,W
05C9:  BSF    03.5
05CA:  MOVWF  07
05CB:  MOVLW  01
05CC:  BCF    03.5
05CD:  MOVWF  14
05CE:  MOVLW  00
05CF:  BSF    03.5
05D0:  MOVWF  14
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_1); 
05D1:  MOVF   01,W
05D2:  ANDLW  C7
05D3:  IORLW  08
05D4:  MOVWF  01
....................    setup_timer_1(T1_DISABLED); 
05D5:  BCF    03.5
05D6:  CLRF   10
....................    setup_timer_2(T2_DISABLED, 0, 1); 
05D7:  MOVLW  00
05D8:  MOVWF  78
05D9:  MOVWF  12
05DA:  MOVLW  00
05DB:  BSF    03.5
05DC:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC); 
05DD:  MOVLW  07
05DE:  MOVWF  1C
05DF:  MOVF   05,W
05E0:  MOVWF  05
05E1:  MOVLW  03
05E2:  MOVWF  77
05E3:  DECFSZ 77,F
05E4:  GOTO   5E3
05E5:  MOVF   1C,W
05E6:  BCF    03.5
05E7:  BCF    0D.6
....................    setup_vref(FALSE); 
05E8:  BSF    03.5
05E9:  CLRF   1D
....................    lcd_ini(); // Inicializa LCD 
05EA:  BCF    03.5
05EB:  GOTO   112
....................    delay_ms(10); 
05EC:  MOVLW  0A
05ED:  MOVWF  3B
05EE:  CALL   0B2
....................    init_ext_eeprom(); 
05EF:  GOTO   153
....................    delay_ms(10); 
05F0:  MOVLW  0A
05F1:  MOVWF  3B
05F2:  CALL   0B2
....................  
....................    // Grava ID e senha do Admin 
....................    write_ext_eeprom(0x0, 0); 
05F3:  CLRF   2F
05F4:  CLRF   2E
05F5:  CLRF   30
05F6:  CALL   1E5
....................    write_ext_eeprom(0x1, '0'); 
05F7:  CLRF   2F
05F8:  MOVLW  01
05F9:  MOVWF  2E
05FA:  MOVLW  30
05FB:  MOVWF  30
05FC:  CALL   1E5
....................    write_ext_eeprom(0x2, '0'); 
05FD:  CLRF   2F
05FE:  MOVLW  02
05FF:  MOVWF  2E
0600:  MOVLW  30
0601:  MOVWF  30
0602:  CALL   1E5
....................    write_ext_eeprom(0x3, '0'); 
0603:  CLRF   2F
0604:  MOVLW  03
0605:  MOVWF  2E
0606:  MOVLW  30
0607:  MOVWF  30
0608:  CALL   1E5
....................    write_ext_eeprom(0x4, '0'); 
0609:  CLRF   2F
060A:  MOVLW  04
060B:  MOVWF  2E
060C:  MOVLW  30
060D:  MOVWF  30
060E:  CALL   1E5
....................  
....................    int8 i; 
....................    int16 j; 
....................    for (i = 0; i < 4; i++) 
060F:  CLRF   2B
0610:  MOVF   2B,W
0611:  SUBLW  03
0612:  BTFSS  03.0
0613:  GOTO   61B
....................    { 
....................       senha[i] = 0; 
0614:  MOVLW  23
0615:  ADDWF  2B,W
0616:  MOVWF  04
0617:  BCF    03.7
0618:  CLRF   00
....................    } 
0619:  INCF   2B,F
061A:  GOTO   610
....................  
....................    while (true) 
....................    { 
....................       desenhaTelaInicial(); 
061B:  GOTO   2B5
....................       delay_ms(300); 
061C:  MOVLW  02
061D:  MOVWF  2E
061E:  MOVLW  96
061F:  MOVWF  3B
0620:  CALL   0B2
0621:  DECFSZ 2E,F
0622:  GOTO   61E
....................       tmp = tc_tecla(200); 
0623:  MOVLW  C8
0624:  MOVWF  2E
0625:  CALL   2CD
0626:  MOVF   78,W
0627:  MOVWF  27
....................  
....................       if (eTeclaValida(tmp)) 
0628:  MOVF   27,W
0629:  MOVWF  2E
062A:  CALL   3F3
062B:  MOVF   78,F
062C:  BTFSC  03.2
062D:  GOTO   726
....................       { 
....................          switch (tmp) 
....................          { 
062E:  MOVF   27,W
062F:  XORLW  31
0630:  BTFSC  03.2
0631:  GOTO   639
0632:  XORLW  03
0633:  BTFSC  03.2
0634:  GOTO   6AE
0635:  XORLW  18
0636:  BTFSC  03.2
0637:  GOTO   6F4
0638:  GOTO   71E
....................          case '1': 
....................             printf(lcd_escreve, "\fID User: "); 
0639:  MOVLW  63
063A:  BSF    03.6
063B:  MOVWF  0D
063C:  MOVLW  00
063D:  MOVWF  0F
063E:  BCF    03.6
063F:  CALL   26F
....................             tmp = tc_tecla(200); 
0640:  MOVLW  C8
0641:  MOVWF  2E
0642:  CALL   2CD
0643:  MOVF   78,W
0644:  MOVWF  27
....................             while (!eTeclaValida(tmp)) 
....................             { 
0645:  MOVF   27,W
0646:  MOVWF  2E
0647:  CALL   3F3
0648:  MOVF   78,F
0649:  BTFSS  03.2
064A:  GOTO   658
....................                printf(lcd_escreve, "\fID User: "); 
064B:  MOVLW  69
064C:  BSF    03.6
064D:  MOVWF  0D
064E:  MOVLW  00
064F:  MOVWF  0F
0650:  BCF    03.6
0651:  CALL   26F
....................                tmp = tc_tecla(200); 
0652:  MOVLW  C8
0653:  MOVWF  2E
0654:  CALL   2CD
0655:  MOVF   78,W
0656:  MOVWF  27
....................             } 
0657:  GOTO   645
....................             if (!confereUserJaExiste(tmp)) 
0658:  MOVF   27,W
0659:  MOVWF  2E
065A:  GOTO   4DE
065B:  MOVF   78,F
065C:  BTFSC  03.2
....................                break; 
065D:  GOTO   726
....................             printf(lcd_escreve, "%c", tmp); 
065E:  MOVF   27,W
065F:  MOVWF  3A
0660:  CALL   237
....................             write_ext_eeprom(posMemoria, tmp); 
0661:  MOVF   2A,W
0662:  MOVWF  2F
0663:  MOVF   29,W
0664:  MOVWF  2E
0665:  MOVF   27,W
0666:  MOVWF  30
0667:  CALL   1E5
....................             posMemoria++; 
0668:  INCF   29,F
0669:  BTFSC  03.2
066A:  INCF   2A,F
....................             printf(lcd_escreve, "\nSenha: "); 
066B:  MOVLW  6F
066C:  BSF    03.6
066D:  MOVWF  0D
066E:  MOVLW  00
066F:  MOVWF  0F
0670:  BCF    03.6
0671:  CALL   26F
....................             tmp = tc_tecla(200); 
0672:  MOVLW  C8
0673:  MOVWF  2E
0674:  CALL   2CD
0675:  MOVF   78,W
0676:  MOVWF  27
....................             for (i = 0; i < 4; i++) 
0677:  CLRF   2B
0678:  MOVF   2B,W
0679:  SUBLW  03
067A:  BTFSS  03.0
067B:  GOTO   69F
....................             { 
....................                tmp = 'j'; 
067C:  MOVLW  6A
067D:  MOVWF  27
....................                while (!eTeclaValida(tmp)) 
....................                { 
067E:  MOVF   27,W
067F:  MOVWF  2E
0680:  CALL   3F3
0681:  MOVF   78,F
0682:  BTFSS  03.2
0683:  GOTO   68A
....................                   tmp = tc_tecla(200); 
0684:  MOVLW  C8
0685:  MOVWF  2E
0686:  CALL   2CD
0687:  MOVF   78,W
0688:  MOVWF  27
....................                } 
0689:  GOTO   67E
....................                senha[i] = tmp; 
068A:  MOVLW  23
068B:  ADDWF  2B,W
068C:  MOVWF  04
068D:  BCF    03.7
068E:  MOVF   27,W
068F:  MOVWF  00
....................                printf(lcd_escreve, "%c", tmp); 
0690:  MOVF   27,W
0691:  MOVWF  3A
0692:  CALL   237
....................                write_ext_eeprom(posMemoria, tmp); 
0693:  MOVF   2A,W
0694:  MOVWF  2F
0695:  MOVF   29,W
0696:  MOVWF  2E
0697:  MOVF   27,W
0698:  MOVWF  30
0699:  CALL   1E5
....................                posMemoria++; 
069A:  INCF   29,F
069B:  BTFSC  03.2
069C:  INCF   2A,F
....................             } 
069D:  INCF   2B,F
069E:  GOTO   678
....................             printf(lcd_escreve, "\fSenha cadastrada\ncom sucesso!"); 
069F:  MOVLW  74
06A0:  BSF    03.6
06A1:  MOVWF  0D
06A2:  MOVLW  00
06A3:  MOVWF  0F
06A4:  BCF    03.6
06A5:  CALL   26F
....................             delay_ms(1000); 
06A6:  MOVLW  04
06A7:  MOVWF  2E
06A8:  MOVLW  FA
06A9:  MOVWF  3B
06AA:  CALL   0B2
06AB:  DECFSZ 2E,F
06AC:  GOTO   6A8
....................             // main(); 
....................             break; 
06AD:  GOTO   726
....................          case '2': 
....................             printf(lcd_escreve, "\fID User: "); 
06AE:  MOVLW  84
06AF:  BSF    03.6
06B0:  MOVWF  0D
06B1:  MOVLW  00
06B2:  MOVWF  0F
06B3:  BCF    03.6
06B4:  CALL   26F
....................             tmp = tc_tecla(200); 
06B5:  MOVLW  C8
06B6:  MOVWF  2E
06B7:  CALL   2CD
06B8:  MOVF   78,W
06B9:  MOVWF  27
....................             while (!eTeclaValida(tmp)) 
....................             { 
06BA:  MOVF   27,W
06BB:  MOVWF  2E
06BC:  CALL   3F3
06BD:  MOVF   78,F
06BE:  BTFSS  03.2
06BF:  GOTO   6C6
....................                tmp = tc_tecla(200); 
06C0:  MOVLW  C8
06C1:  MOVWF  2E
06C2:  CALL   2CD
06C3:  MOVF   78,W
06C4:  MOVWF  27
....................             } 
06C5:  GOTO   6BA
....................             user = tmp; 
06C6:  MOVF   27,W
06C7:  MOVWF  28
....................             printf(lcd_escreve, "\fStatus: FECHADA\nSenha: "); 
06C8:  MOVLW  8A
06C9:  BSF    03.6
06CA:  MOVWF  0D
06CB:  MOVLW  00
06CC:  MOVWF  0F
06CD:  BCF    03.6
06CE:  CALL   26F
....................             for (i = 0; i < 4; i++) 
06CF:  CLRF   2B
06D0:  MOVF   2B,W
06D1:  SUBLW  03
06D2:  BTFSS  03.0
06D3:  GOTO   6ED
....................             { 
....................                tmp = 'j'; 
06D4:  MOVLW  6A
06D5:  MOVWF  27
....................                while (!eTeclaValida(tmp)) 
....................                { 
06D6:  MOVF   27,W
06D7:  MOVWF  2E
06D8:  CALL   3F3
06D9:  MOVF   78,F
06DA:  BTFSS  03.2
06DB:  GOTO   6E2
....................                   tmp = tc_tecla(200); 
06DC:  MOVLW  C8
06DD:  MOVWF  2E
06DE:  CALL   2CD
06DF:  MOVF   78,W
06E0:  MOVWF  27
....................                } 
06E1:  GOTO   6D6
....................                printf(lcd_escreve, "%c", tmp); 
06E2:  MOVF   27,W
06E3:  MOVWF  3A
06E4:  CALL   237
....................                senha[i] = tmp; 
06E5:  MOVLW  23
06E6:  ADDWF  2B,W
06E7:  MOVWF  04
06E8:  BCF    03.7
06E9:  MOVF   27,W
06EA:  MOVWF  00
....................             } 
06EB:  INCF   2B,F
06EC:  GOTO   6D0
....................             confereSenha(user, senha); 
06ED:  MOVF   28,W
06EE:  MOVWF  2E
06EF:  CLRF   30
06F0:  MOVLW  23
06F1:  MOVWF  2F
06F2:  GOTO   508
....................             break; 
06F3:  GOTO   726
....................          case '*': 
....................             printf(lcd_escreve, "\fLIMPANDO MEMORIA"); 
06F4:  MOVLW  97
06F5:  BSF    03.6
06F6:  MOVWF  0D
06F7:  MOVLW  00
06F8:  MOVWF  0F
06F9:  BCF    03.6
06FA:  CALL   26F
....................             delay_ms(200); 
06FB:  MOVLW  C8
06FC:  MOVWF  3B
06FD:  CALL   0B2
....................             for (j = 0; j < 1024; j++) 
06FE:  CLRF   2D
06FF:  CLRF   2C
0700:  MOVF   2D,W
0701:  SUBLW  03
0702:  BTFSS  03.0
0703:  GOTO   70F
....................             { 
....................                write_ext_eeprom(j, 'F'); 
0704:  MOVF   2D,W
0705:  MOVWF  2F
0706:  MOVF   2C,W
0707:  MOVWF  2E
0708:  MOVLW  46
0709:  MOVWF  30
070A:  CALL   1E5
....................             } 
070B:  INCF   2C,F
070C:  BTFSC  03.2
070D:  INCF   2D,F
070E:  GOTO   700
....................             printf(lcd_escreve, "\fMEMORIA LIMPA"); 
070F:  MOVLW  A0
0710:  BSF    03.6
0711:  MOVWF  0D
0712:  MOVLW  00
0713:  MOVWF  0F
0714:  BCF    03.6
0715:  CALL   26F
....................             delay_ms(1000); 
0716:  MOVLW  04
0717:  MOVWF  2E
0718:  MOVLW  FA
0719:  MOVWF  3B
071A:  CALL   0B2
071B:  DECFSZ 2E,F
071C:  GOTO   718
....................             break; 
071D:  GOTO   726
....................          default: 
....................             printf(lcd_escreve, "\fERRO DESCONHECIDO"); 
071E:  MOVLW  A8
071F:  BSF    03.6
0720:  MOVWF  0D
0721:  MOVLW  00
0722:  MOVWF  0F
0723:  BCF    03.6
0724:  CALL   26F
....................             break; 
0725:  GOTO   726
....................          } 
....................       } 
....................    } 
0726:  GOTO   61B
.................... } 
0727:  SLEEP

Configuration Fuses:
   Word  1: 3F79   XT NOWDT NOPUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
